diff --git a/README.md b/README.md
new file mode 100644
index 0000000..af10427
--- /dev/null
+++ b/README.md
@@ -0,0 +1,55 @@
+# Description
+This is my experimental OpenGL 4 branch of 0 A.D., a free, open-source, cross-platform real-time strategy game of ancient warfare. This branch aims to improve rendering performance by reducing driver overhead.
+Check out these links for some information about the techniques I'm working with:
+
+ - [Text - The Road to One Million Draws](http://www.openglsuperbible.com/2013/10/16/the-road-to-one-million-draws/)
+ - [Video - Beyond Porting: How Modern OpenGL Can Radically Reduce Driver Overhead](https://www.youtube.com/watch?v=-bCeNzgiJ8I)
+
+I'm starting with the model renderer and other rendering code is currently out of scope (terrain, UI etc.).
+
+# Installing and testing
+The instructions for compiling the game on Windows, Linux and OS X are at
+http://trac.wildfiregames.com/wiki/BuildInstructions
+
+In addition, set the following required configuration settings in your local.cfg/user.cfg:
+```
+gpuskinning = true
+preferglsl = "true"
+gentangents = "true"
+```
+
+# Known issues
+ - It's currently just "hacked" to work with very specific settings and breaks other rendering modes
+ - The Mesa 3D drivers on Linux only support up to OpenGL 3.3, and this only for OpenGL contexts in the core profile. At the moment you have to install proprietary drivers.
+ - Many open TODOs
+ 
+# Tasks
+- [ ] Avoid uniform related state changes and validation overhead
+  - [x] Use uniform blocks in the model renderer shaders
+  - [x] Write code to manage uniform blocks (binding, creating buffers, storing uniform data at the right place in the buffers etc.)
+  - [x] Extend material XML files and the parser code with uniform block information
+  - [ ] Find a way to avoid writing uniform data based on conditional defines. Currently we write a lot of per-model data which is never used by the shader. We can't use the preprocessor defines the same way as we used them before.
+- [ ] Implement drawing using glMultiDrawElementsIndirect
+  - [x] Implement code to generate the draw commands, fill the buffer and draw using glMultiDrawElementsIndirect. Avoid uploading the buffer per draw.
+  - [ ] Actually start making use of instancing and draw multiple objects in one draw call.
+- [ ] Avoid texture related state changes and validation overhead
+- [ ] Consider other improvements to avoid state changes
+
+# Performance state
+Currently the performance is slightly better in the OGL4 branch on my system (Linux, AMD R9 X270, FGLRX driver). 
+Here are some test results. I'm not specifying all the details (settings, match setup details, camera perspective etc.), these results should just roughly indicate a trend.
+I've treid different settings (shadows, silhouettes etc.) and there was always an improvement.
+
+**Combat demo (huge):**
+```
+SVN: 13-14 FPS
+OGL4 branch: 17-19 FPS 
+```
+
+
+**Deep forest:**
+```
+SVN: 19-21 FPS
+OGL4 branch: 21-23 FPS
+```
+
diff --git a/binaries/data/mods/public/art/materials/alphatest_spec.xml b/binaries/data/mods/public/art/materials/alphatest_spec.xml
index cf5d2d0..f2eb2b9 100644
--- a/binaries/data/mods/public/art/materials/alphatest_spec.xml
+++ b/binaries/data/mods/public/art/materials/alphatest_spec.xml
@@ -5,7 +5,7 @@
     <define name="USE_ALPHATEST" value="1"/>
 
     <define name="USE_SPECULAR" value="1"/>
-    <uniform name="specularPower" value="16.0"/>
-    <uniform name="specularColor" value="1.0 1.0 1.0"/>
+    <uniform instanced="1" blockName="MaterialUBO" name="specularPower[0]" value="16.0"/>
+    <uniform instanced="1" blockName="MaterialUBO" name="specularColor[0]" value="1.0 1.0 1.0"/>
 	<required_texture name="baseTex"/>
 </material>
diff --git a/binaries/data/mods/public/art/materials/aura.xml b/binaries/data/mods/public/art/materials/aura.xml
index 50e8e5e..aab7fc7 100644
--- a/binaries/data/mods/public/art/materials/aura.xml
+++ b/binaries/data/mods/public/art/materials/aura.xml
@@ -5,8 +5,8 @@
     <renderquery name="sim_time"/>
     <uniform name="translation" value="0.0 -0.1"/>
 	<define name="USE_SELF_LIGHT" value="1"/>
-	<uniform name="specularPower" value="100.0"/>
-    <uniform name="specularColor" value="1.0 1.0 1.0"/>
+	<uniform instanced="1" blockName="MaterialUBO" name="specularPower[0]" value="100.0"/>
+    <uniform instanced="1" blockName="MaterialUBO" name="specularColor[0]" value="1.0 1.0 1.0"/>
 	<required_texture name="baseTex"/>
 	<required_texture name="specTex" define="USE_SPECULAR_MAP"/>
 </material>
diff --git a/binaries/data/mods/public/art/materials/basic_glow.xml b/binaries/data/mods/public/art/materials/basic_glow.xml
index 5c7d083..1049a8e 100644
--- a/binaries/data/mods/public/art/materials/basic_glow.xml
+++ b/binaries/data/mods/public/art/materials/basic_glow.xml
@@ -7,5 +7,5 @@
 	<alternative material="alphatest_ao_parallax_spec.xml" if="CFG_FORCE_ALPHATEST"/>
 	<define name="USE_SPECULAR_MAP" value="1"/>
 	<define name="USE_SELF_LIGHT" value="1"/>
-	<uniform name="effectSettings" value="1.0 50.0 0.0075 0.85"/>
+	<uniform blockName="MaterialUBO" name="effectSettings[0]" instanced="1"  value="1.0 50.0 0.0075 0.85"/>
 </material>
diff --git a/binaries/data/mods/public/art/materials/basic_spec.xml b/binaries/data/mods/public/art/materials/basic_spec.xml
index ee321eb..366525e 100644
--- a/binaries/data/mods/public/art/materials/basic_spec.xml
+++ b/binaries/data/mods/public/art/materials/basic_spec.xml
@@ -3,8 +3,8 @@
     <shader effect="model"/>
 
     <define name="USE_SPECULAR" value="1"/>
-    <uniform name="specularPower" value="16.0"/>
-    <uniform name="specularColor" value="1.0 1.0 1.0"/>
+    <uniform instanced="1" blockName="MaterialUBO" name="specularPower[0]" value="16.0"/>
+    <uniform instanced="1" blockName="MaterialUBO" name="specularColor[0]" value="1.0 1.0 1.0"/>
 	
 	<required_texture name="baseTex"/>
 </material>
diff --git a/binaries/data/mods/public/art/materials/basic_specmap.xml b/binaries/data/mods/public/art/materials/basic_specmap.xml
index 58bb437..1a191d2 100644
--- a/binaries/data/mods/public/art/materials/basic_specmap.xml
+++ b/binaries/data/mods/public/art/materials/basic_specmap.xml
@@ -16,7 +16,7 @@
 	 Second value: Specular power.
 	 Third value: Parallax scale.
 	 Fourth value: AO amount. -->
-    <uniform name="effectSettings" value="1.0 25.0 0.0075 0.85"/>
+    <uniform blockName="MaterialUBO" name="effectSettings[0]" instanced="1" value="1.0 25.0 0.0075 0.85"/>
 	
 	<required_texture name="baseTex"/>
 	<required_texture name="specTex" define="USE_SPECULAR_MAP"/>
diff --git a/binaries/data/mods/public/art/materials/basic_trans_ao.xml b/binaries/data/mods/public/art/materials/basic_trans_ao.xml
index c0b6afe..18910b8 100644
--- a/binaries/data/mods/public/art/materials/basic_trans_ao.xml
+++ b/binaries/data/mods/public/art/materials/basic_trans_ao.xml
@@ -20,7 +20,7 @@
 	 Second value: Specular power.
 	 Third value: Parallax scale.
 	 Fourth value: AO amount. -->
-    <uniform name="effectSettings" value="1.0 50.0 0.0075 0.85"/>
+    <uniform blockName="MaterialUBO" name="effectSettings[0]" instanced="1" value="1.0 50.0 0.0075 0.85"/>
 	
 	<required_texture name="baseTex"/>
 	<required_texture name="aoTex" define="USE_AO"/>
diff --git a/binaries/data/mods/public/art/materials/basic_trans_ao_parallax_spec.xml b/binaries/data/mods/public/art/materials/basic_trans_ao_parallax_spec.xml
index 6b52a54..d21fb6a 100644
--- a/binaries/data/mods/public/art/materials/basic_trans_ao_parallax_spec.xml
+++ b/binaries/data/mods/public/art/materials/basic_trans_ao_parallax_spec.xml
@@ -13,7 +13,7 @@
 	 Second value: Specular power.
 	 Third value: Parallax scale.
 	 Fourth value: AO amount. -->
-    <uniform name="effectSettings" value="1.0 50.0 0.0075 0.85"/>
+    <uniform blockName="MaterialUBO" name="effectSettings[0]" instanced="1" value="1.0 50.0 0.0075 0.85"/>
 	
 	<required_texture name="baseTex"/>
 	<required_texture name="normTex" define="USE_NORMAL_MAP"/>
diff --git a/binaries/data/mods/public/art/materials/basic_trans_ao_spec.xml b/binaries/data/mods/public/art/materials/basic_trans_ao_spec.xml
index 09291b3..97e9a03 100644
--- a/binaries/data/mods/public/art/materials/basic_trans_ao_spec.xml
+++ b/binaries/data/mods/public/art/materials/basic_trans_ao_spec.xml
@@ -19,7 +19,7 @@
 	 Second value: Specular power.
 	 Third value: Parallax scale.
 	 Fourth value: AO amount. -->
-    <uniform name="effectSettings" value="1.0 50.0 0.0075 0.85"/>
+    <uniform blockName="MaterialUBO" name="effectSettings[0]" instanced="1" value="1.0 50.0 0.0075 0.85"/>
 	
 	<required_texture name="baseTex"/>
 	<required_texture name="specTex" define="USE_SPECULAR_MAP"/>
diff --git a/binaries/data/mods/public/art/materials/basic_trans_parallax_spec.xml b/binaries/data/mods/public/art/materials/basic_trans_parallax_spec.xml
index b891497..b5b392e 100644
--- a/binaries/data/mods/public/art/materials/basic_trans_parallax_spec.xml
+++ b/binaries/data/mods/public/art/materials/basic_trans_parallax_spec.xml
@@ -13,7 +13,7 @@
 	 Second value: Specular power.
 	 Third value: Parallax scale.
 	 Fourth value: AO amount. -->
-    <uniform name="effectSettings" value="1.0 50.0 0.0075 0.85"/>
+    <uniform blockName="MaterialUBO" name="effectSettings[0]" instanced="1"  value="1.0 50.0 0.0075 0.85"/>
 	<required_texture name="baseTex"/>
 	<required_texture name="specTex" define="USE_SPECULAR_MAP"/>
 	<required_texture name="normTex" define="USE_NORMAL_MAP"/>
diff --git a/binaries/data/mods/public/art/materials/basic_trans_spec.xml b/binaries/data/mods/public/art/materials/basic_trans_spec.xml
index 4afcbef..f2dfd4f 100644
--- a/binaries/data/mods/public/art/materials/basic_trans_spec.xml
+++ b/binaries/data/mods/public/art/materials/basic_trans_spec.xml
@@ -18,7 +18,7 @@
 	 Second value: Specular power.
 	 Third value: Parallax scale.
 	 Fourth value: AO amount. -->
-    <uniform name="effectSettings" value="1.0 50.0 0.0075 0.85"/>
+    <uniform blockName="MaterialUBO" name="effectSettings[0]" instanced="1" value="1.0 50.0 0.0075 0.85"/>
 	
 	<required_texture name="baseTex"/>
 	<required_texture name="specTex" define="USE_SPECULAR_MAP"/>
diff --git a/binaries/data/mods/public/art/materials/basic_trans_wind.xml b/binaries/data/mods/public/art/materials/basic_trans_wind.xml
index df4ae77..2d02ff5 100644
--- a/binaries/data/mods/public/art/materials/basic_trans_wind.xml
+++ b/binaries/data/mods/public/art/materials/basic_trans_wind.xml
@@ -6,6 +6,6 @@
     <define name="USE_TRANSPARENT" value="1"/>
     <renderquery name="sim_time"/>
     <define name="USE_WIND" value="1"/>
-    <uniform name="windData" value="1.0 1.0"/>
+    <uniform instanced="1" blockName="MaterialUBO" name="windData[0]" value="1.0 1.0"/>
 	<required_texture name="baseTex"/>
 </material>
diff --git a/binaries/data/mods/public/art/materials/blend_spec.xml b/binaries/data/mods/public/art/materials/blend_spec.xml
index b59afca..ec16b40 100644
--- a/binaries/data/mods/public/art/materials/blend_spec.xml
+++ b/binaries/data/mods/public/art/materials/blend_spec.xml
@@ -7,7 +7,7 @@
     <define name="USE_TRANSPARENT" value="1"/>
 
     <define name="USE_SPECULAR" value="1"/>
-    <uniform name="specularPower" value="16.0"/>
-    <uniform name="specularColor" value="1.0 1.0 1.0"/>
+    <uniform instanced="1" blockName="MaterialUBO" name="specularPower[0]" value="16.0"/>
+    <uniform instanced="1" blockName="MaterialUBO" name="specularColor[0]" value="1.0 1.0 1.0"/>
 	<required_texture name="baseTex"/>
 </material>
diff --git a/binaries/data/mods/public/art/materials/material.rnc b/binaries/data/mods/public/art/materials/material.rnc
index f9bbf92..f37886c 100644
--- a/binaries/data/mods/public/art/materials/material.rnc
+++ b/binaries/data/mods/public/art/materials/material.rnc
@@ -26,6 +26,8 @@ element material {
     }*
   & element uniform {
       attribute name { text },
+      attribute blockName { text }?,
+      attribute instanced { xsd:int }?,
       attribute value {
         list {
           # X Y Z W
diff --git a/binaries/data/mods/public/art/materials/material.rng b/binaries/data/mods/public/art/materials/material.rng
index 62b7479..a9e339f 100644
--- a/binaries/data/mods/public/art/materials/material.rng
+++ b/binaries/data/mods/public/art/materials/material.rng
@@ -42,6 +42,14 @@
     <zeroOrMore>
       <element name="uniform">
         <attribute name="name"/>
+        <optional>
+          <attribute name="blockName"/>
+        </optional>
+        <optional>
+          <attribute name="instanced">
+            <data type="int"/>
+          </attribute>
+        </optional>
         <attribute name="value">
           <list>
             <!-- X Y Z W -->
diff --git a/binaries/data/mods/public/art/materials/no_trans_ao.xml b/binaries/data/mods/public/art/materials/no_trans_ao.xml
index 714f287..c92f11b 100644
--- a/binaries/data/mods/public/art/materials/no_trans_ao.xml
+++ b/binaries/data/mods/public/art/materials/no_trans_ao.xml
@@ -17,7 +17,7 @@
 	 Second value: Specular power.
 	 Third value: Parallax scale.
 	 Fourth value: AO amount. -->
-    <uniform name="effectSettings" value="1.0 50.0 0.0075 0.85"/>
+    <uniform blockName="MaterialUBO" name="effectSettings[0]" instanced="1" value="1.0 50.0 0.0075 0.85"/>
 	
 	<required_texture name="baseTex"/>
 	<required_texture name="aoTex" define="USE_AO"/>
diff --git a/binaries/data/mods/public/art/materials/no_trans_parallax_ao.xml b/binaries/data/mods/public/art/materials/no_trans_parallax_ao.xml
index 37c2b45..07528e7 100644
--- a/binaries/data/mods/public/art/materials/no_trans_parallax_ao.xml
+++ b/binaries/data/mods/public/art/materials/no_trans_parallax_ao.xml
@@ -10,7 +10,7 @@
 	 Second value: Specular power.
 	 Third value: Parallax scale.
 	 Fourth value: AO amount. -->
-    <uniform name="effectSettings" value="1.0 50.0 0.0075 0.85"/>
+    <uniform blockName="MaterialUBO" name="effectSettings[0]" instanced="1" value="1.0 50.0 0.0075 0.85"/>
 	<required_texture name="baseTex"/>
 	<required_texture name="normTex" define="USE_NORMAL_MAP"/>
 	<required_texture name="aoTex" define="USE_AO"/>
diff --git a/binaries/data/mods/public/art/materials/objectcolor_spec.xml b/binaries/data/mods/public/art/materials/objectcolor_spec.xml
index 824ea2b..43de847 100644
--- a/binaries/data/mods/public/art/materials/objectcolor_spec.xml
+++ b/binaries/data/mods/public/art/materials/objectcolor_spec.xml
@@ -5,8 +5,10 @@
     <define name="USE_OBJECTCOLOR" value="1"/>
 
     <define name="USE_SPECULAR" value="1"/>
-    <uniform name="specularPower" value="16.0"/>
-    <uniform name="specularColor" value="1.0 1.0 1.0"/>
+    <uniform instanced="1" blockName="MaterialUBO" name="specularPower[0]" value="16.0"/>
+    <uniform instanced="1" blockName="MaterialUBO" name="specularColor[0]" value="1.0 1.0 1.0"/>
+    <uniform instanced="1" blockName="MaterialUBO" name="specularPower[0]" value="16.0"/>
+    <uniform instanced="1" blockName="MaterialUBO" name="specularColor[0]" value="1.0 1.0 1.0"/>
 
 <required_texture name="baseTex"/>
 </material>
diff --git a/binaries/data/mods/public/art/materials/objectcolor_specmap.xml b/binaries/data/mods/public/art/materials/objectcolor_specmap.xml
index 47d7c89..e56a4ad 100644
--- a/binaries/data/mods/public/art/materials/objectcolor_specmap.xml
+++ b/binaries/data/mods/public/art/materials/objectcolor_specmap.xml
@@ -4,7 +4,7 @@
 
     <define name="USE_OBJECTCOLOR" value="1"/>
 
-    <uniform name="effectSettings" value="1.0 50.0 0.0075 0.85"/>
+    <uniform blockName="MaterialUBO" name="effectSettings[0]" instanced="1" value="1.0 50.0 0.0075 0.85"/>
 	
 	<required_texture name="baseTex"/>
 	<required_texture name="specTex" define="USE_SPECULAR_MAP"/>
diff --git a/binaries/data/mods/public/art/materials/player_trans_ao.xml b/binaries/data/mods/public/art/materials/player_trans_ao.xml
index 1bba20a..ed41150 100644
--- a/binaries/data/mods/public/art/materials/player_trans_ao.xml
+++ b/binaries/data/mods/public/art/materials/player_trans_ao.xml
@@ -18,7 +18,9 @@
 	 Second value: Specular power.
 	 Third value: Parallax scale.
 	 Fourth value: AO amount. -->
-    <uniform name="effectSettings" value="1.0 50.0 0.0075 0.6"/>
+    <!-- <uniform name="effectSettings" value="1.0 50.0 0.0075 0.6"/> -->
+    <uniform blockName="MaterialUBO" name="effectSettings[0]" instanced="1" value="1.0 50.0 0.0075 0.6"/>
+
 	
 	<required_texture name="baseTex"/>
 	<required_texture name="aoTex" define="USE_AO"/>
diff --git a/binaries/data/mods/public/art/materials/player_trans_ao_parallax.xml b/binaries/data/mods/public/art/materials/player_trans_ao_parallax.xml
index e054964..5b1c874 100644
--- a/binaries/data/mods/public/art/materials/player_trans_ao_parallax.xml
+++ b/binaries/data/mods/public/art/materials/player_trans_ao_parallax.xml
@@ -6,7 +6,7 @@
 
     <define name="USE_PARALLAX" value="1"/>
 
-	<uniform name="effectSettings" value="1.0 50.0 0.0075 0.6"/>
+	<uniform blockName="MaterialUBO" name="effectSettings[0]" instanced="1" value="1.0 50.0 0.0075 0.6"/>
 	
 	<required_texture name="baseTex"/>
 	<required_texture name="normTex" define="USE_NORMAL_MAP"/>
diff --git a/binaries/data/mods/public/art/materials/player_trans_ao_parallax_spec.xml b/binaries/data/mods/public/art/materials/player_trans_ao_parallax_spec.xml
index 1698ca1..f156f68 100644
--- a/binaries/data/mods/public/art/materials/player_trans_ao_parallax_spec.xml
+++ b/binaries/data/mods/public/art/materials/player_trans_ao_parallax_spec.xml
@@ -11,7 +11,7 @@
 	 Second value: Specular power.
 	 Third value: Parallax scale.
 	 Fourth value: AO amount. -->
-    <uniform name="effectSettings" value="1.0 50.0 0.0075 0.6"/>
+    <uniform blockName="MaterialUBO" name="effectSettings[0]" instanced="1" value="1.0 50.0 0.0075 0.6"/>
 	
 	<required_texture name="baseTex"/>
 	<required_texture name="normTex" define="USE_NORMAL_MAP"/>
diff --git a/binaries/data/mods/public/art/materials/player_trans_ao_spec.xml b/binaries/data/mods/public/art/materials/player_trans_ao_spec.xml
index e43390a..8873379 100644
--- a/binaries/data/mods/public/art/materials/player_trans_ao_spec.xml
+++ b/binaries/data/mods/public/art/materials/player_trans_ao_spec.xml
@@ -9,7 +9,7 @@
 	 Second value: Specular power.
 	 Third value: Parallax scale.
 	 Fourth value: AO amount. -->
-    <uniform name="effectSettings" value="1.0 50.0 0.0075 0.85"/>
+    <uniform blockName="MaterialUBO" name="effectSettings[0]" instanced="1" value="1.0 50.0 0.0075 0.85"/>
 	
 	<required_texture name="baseTex"/>
 	<required_texture name="specTex" define="USE_SPECULAR_MAP"/>
diff --git a/binaries/data/mods/public/art/materials/player_trans_parallax.xml b/binaries/data/mods/public/art/materials/player_trans_parallax.xml
index 7512ce5..5d91463 100644
--- a/binaries/data/mods/public/art/materials/player_trans_parallax.xml
+++ b/binaries/data/mods/public/art/materials/player_trans_parallax.xml
@@ -16,7 +16,7 @@
 	 Second value: Specular power.
 	 Third value: Parallax scale. 
 	 Fourth value: AO amount. -->
-    <uniform name="effectSettings" value="1.0 50.0 0.0075 0.75"/>
+    <uniform blockName="MaterialUBO" name="effectSettings[0]" instanced="1" value="1.0 50.0 0.0075 0.75"/>
 	
 	<required_texture name="baseTex"/>
 	<required_texture name="normTex" define="USE_NORMAL_MAP"/>
diff --git a/binaries/data/mods/public/art/materials/player_trans_parallax_spec.xml b/binaries/data/mods/public/art/materials/player_trans_parallax_spec.xml
index bcbe78e..9a340d7 100644
--- a/binaries/data/mods/public/art/materials/player_trans_parallax_spec.xml
+++ b/binaries/data/mods/public/art/materials/player_trans_parallax_spec.xml
@@ -15,7 +15,7 @@
 	 Second value: Specular power.
 	 Third value: Parallax scale.
 	 Fourth value: AO amount. -->
-    <uniform name="effectSettings" value="1.0 50.0 0.0075 0.85"/>
+    <uniform blockName="MaterialUBO" name="effectSettings[0]" instanced="1" value="1.0 50.0 0.0075 0.85"/>
 	
 	<required_texture name="baseTex"/>
 	<required_texture name="specTex" define="USE_SPECULAR_MAP"/>
diff --git a/binaries/data/mods/public/art/materials/player_trans_spec.xml b/binaries/data/mods/public/art/materials/player_trans_spec.xml
index 191aebb..52a26dc 100644
--- a/binaries/data/mods/public/art/materials/player_trans_spec.xml
+++ b/binaries/data/mods/public/art/materials/player_trans_spec.xml
@@ -10,7 +10,7 @@
 	 Second value: Specular power.
 	 Third value: Parallax scale.
 	 Fourth value: AO amount. -->
-    <uniform name="effectSettings" value="1.0 50.0 0.0075 0.85"/>
+    <uniform blockName="MaterialUBO" name="effectSettings[0]" instanced="1" value="1.0 50.0 0.0075 0.85"/>
 	
 	<required_texture name="baseTex"/>
 	<required_texture name="specTex" define="USE_SPECULAR_MAP"/>
diff --git a/binaries/data/mods/public/art/materials/player_trans_spec_helmet.xml b/binaries/data/mods/public/art/materials/player_trans_spec_helmet.xml
index 017999b..0c0d12d 100644
--- a/binaries/data/mods/public/art/materials/player_trans_spec_helmet.xml
+++ b/binaries/data/mods/public/art/materials/player_trans_spec_helmet.xml
@@ -10,7 +10,8 @@
 	 Second value: Specular power.
 	 Third value: Parallax scale.
 	 Fourth value: AO amount. -->
-    <uniform name="effectSettings" value="1.0 20.0 0.0075 0.85"/>
+    <uniform blockName="MaterialUBO" name="effectSettings[0]" instanced="1" value="1.0 20.0 0.0075 0.85"/>
+
 	
 	<required_texture name="baseTex"/>
 	<required_texture name="specTex" define="USE_SPECULAR_MAP"/>
diff --git a/binaries/data/mods/public/art/materials/playercolor_spec.xml b/binaries/data/mods/public/art/materials/playercolor_spec.xml
index 9db6d27..d3b128d 100644
--- a/binaries/data/mods/public/art/materials/playercolor_spec.xml
+++ b/binaries/data/mods/public/art/materials/playercolor_spec.xml
@@ -5,7 +5,7 @@
     <define name="USE_PLAYERCOLOR" value="1"/>
 
     <define name="USE_SPECULAR" value="1"/>
-    <uniform name="specularPower" value="16.0"/>
-    <uniform name="specularColor" value="1.0 1.0 1.0"/>
+    <uniform instanced="1" blockName="MaterialUBO" name="specularPower[0]" value="16.0"/>
+    <uniform instanced="1" blockName="MaterialUBO" name="specularColor[0]" value="1.0 1.0 1.0"/>
 	<required_texture name="baseTex"/>
 </material>
diff --git a/binaries/data/mods/public/art/materials/rock_bump_spec_ao_test.xml b/binaries/data/mods/public/art/materials/rock_bump_spec_ao_test.xml
index 472e521..ff1542d 100644
--- a/binaries/data/mods/public/art/materials/rock_bump_spec_ao_test.xml
+++ b/binaries/data/mods/public/art/materials/rock_bump_spec_ao_test.xml
@@ -41,7 +41,7 @@
 	 Second value: Specular power.
 	 Third value: Parallax scale.
 	 Fourth value: AO amount. -->
-    <uniform name="effectSettings" value="1.0 10.0 0.0075 0.85"/>
+    <uniform blockName="MaterialUBO" name="effectSettings[0]" instanced="1" value="1.0 10.0 0.0075 0.85"/>
 	
 	<required_texture name="baseTex"/>
 	<required_texture name="specTex" define="USE_SPECULAR_MAP"/>
diff --git a/binaries/data/mods/public/art/materials/rock_bump_spec_test.xml b/binaries/data/mods/public/art/materials/rock_bump_spec_test.xml
index 2fd2460..c8a87df 100644
--- a/binaries/data/mods/public/art/materials/rock_bump_spec_test.xml
+++ b/binaries/data/mods/public/art/materials/rock_bump_spec_test.xml
@@ -42,7 +42,7 @@
 	 Second value: Specular power.
 	 Third value: Parallax scale.
 	 Fourth value: AO amount. -->
-    <uniform name="effectSettings" value="5.0 50.0 0.0075 0.85"/>
+    <uniform blockName="MaterialUBO" name="effectSettings[0]" instanced="1" value="5.0 50.0 0.0075 0.85"/>
 	
 	<required_texture name="baseTex"/>
 	<required_texture name="normTex" define="USE_NORMAL_MAP"/>
diff --git a/binaries/data/mods/public/art/materials/terrain_grass.xml b/binaries/data/mods/public/art/materials/terrain_grass.xml
index 2ca8c94..1dcf8b8 100644
--- a/binaries/data/mods/public/art/materials/terrain_grass.xml
+++ b/binaries/data/mods/public/art/materials/terrain_grass.xml
@@ -4,6 +4,6 @@
     <!--define name="USE_NORMAL_MAP" value="1"/-->
     <!--define name="USE_SPECULAR_MAP" value="1"/-->
     
-    <!--uniform name="specularPower" value="15.0"/-->
+    <!--uniform instanced="1" blockName="MaterialUBO" name="specularPower[0]" value="15.0"/-->
 	<required_texture name="baseTex"/>
 </material>
diff --git a/binaries/data/mods/public/art/materials/terrain_norm.xml b/binaries/data/mods/public/art/materials/terrain_norm.xml
index f6e0d3e..17d71ac 100644
--- a/binaries/data/mods/public/art/materials/terrain_norm.xml
+++ b/binaries/data/mods/public/art/materials/terrain_norm.xml
@@ -3,7 +3,7 @@
     <shader effect="terrain_base"/>
     <alternative material="terrain_base.xml" quality="2"/>
 
-    <uniform name="effectSettings" value="1.0 15.0 0.0 0.0"/>
+    <uniform blockName="MaterialUBO" name="effectSettings[0]" instanced="1" value="1.0 15.0 0.0 0.0"/>
 	<required_texture name="baseTex"/>
 	<required_texture name="normTex" define="USE_NORMAL_MAP"/>
 </material>
diff --git a/binaries/data/mods/public/art/materials/terrain_norm_spec.xml b/binaries/data/mods/public/art/materials/terrain_norm_spec.xml
index a873b8d..8578391 100644
--- a/binaries/data/mods/public/art/materials/terrain_norm_spec.xml
+++ b/binaries/data/mods/public/art/materials/terrain_norm_spec.xml
@@ -3,7 +3,7 @@
     <shader effect="terrain_base"/>
     <alternative material="terrain_norm.xml" quality="4"/>
 
-    <uniform name="effectSettings" value="1.0 15.0 0.0 0.0"/>
+    <uniform blockName="MaterialUBO" name="effectSettings[0]" instanced="1" value="1.0 15.0 0.0 0.0"/>
 	<required_texture name="baseTex"/>
 	<required_texture name="normTex" define="USE_NORMAL_MAP"/>
 	<required_texture name="specTex" define="USE_SPECULAR_MAP"/>
diff --git a/binaries/data/mods/public/art/materials/terrain_triplanar.xml b/binaries/data/mods/public/art/materials/terrain_triplanar.xml
index 9de0388..32f7541 100644
--- a/binaries/data/mods/public/art/materials/terrain_triplanar.xml
+++ b/binaries/data/mods/public/art/materials/terrain_triplanar.xml
@@ -5,6 +5,6 @@
 
     <define name="USE_TRIPLANAR" value="1"/>
     
-    <uniform name="effectSettings" value="1.0 15.0 0.0 0.0"/>
+    <uniform blockName="MaterialUBO" name="effectSettings[0]" instanced="1" value="1.0 15.0 0.0 0.0"/>
 	<required_texture name="baseTex"/>
 </material>
diff --git a/binaries/data/mods/public/art/materials/terrain_triplanar_norm_spec.xml b/binaries/data/mods/public/art/materials/terrain_triplanar_norm_spec.xml
index 2bca4c7..0b9e720 100644
--- a/binaries/data/mods/public/art/materials/terrain_triplanar_norm_spec.xml
+++ b/binaries/data/mods/public/art/materials/terrain_triplanar_norm_spec.xml
@@ -5,7 +5,7 @@
 
     <define name="USE_TRIPLANAR" value="1"/>
     
-    <uniform name="effectSettings" value="1.0 15.0 0.0 0.0"/>
+    <uniform blockName="MaterialUBO" name="effectSettings[0]" instanced="1" value="1.0 15.0 0.0 0.0"/>
 	<required_texture name="baseTex"/>
 	<required_texture name="normTex" define="USE_NORMAL_MAP"/>
 	<required_texture name="specTex" define="USE_SPECULAR_MAP"/>
diff --git a/binaries/data/mods/public/art/materials/trans_wind.xml b/binaries/data/mods/public/art/materials/trans_wind.xml
index bcadbf4..d432679 100644
--- a/binaries/data/mods/public/art/materials/trans_wind.xml
+++ b/binaries/data/mods/public/art/materials/trans_wind.xml
@@ -3,6 +3,6 @@
     <shader effect="model"/>
     <renderquery name="sim_time"/>
     <define name="USE_WIND" value="1"/>
-    <uniform name="windData" value="1.0 1.0"/>
+    <uniform instanced="1" blockName="MaterialUBO" name="windData[0]" value="1.0 1.0"/>
 	<required_texture name="baseTex"/>
 </material>
diff --git a/binaries/data/mods/public/art/materials/trans_wind_parallax_spec.xml b/binaries/data/mods/public/art/materials/trans_wind_parallax_spec.xml
index 321eb86..cb634be 100644
--- a/binaries/data/mods/public/art/materials/trans_wind_parallax_spec.xml
+++ b/binaries/data/mods/public/art/materials/trans_wind_parallax_spec.xml
@@ -4,11 +4,11 @@
     <alpha_blending/>
     <define name="USE_TRANSPARENT" value="1"/>
     <define name="USE_PARALLAX" value="1"/>
-    <uniform name="effectSettings" value="1.0 50.0 0.0075 0.85"/>
+    <uniform blockName="MaterialUBO" name="effectSettings[0]" instanced="1" value="1.0 50.0 0.0075 0.85"/>
 	
     <renderquery name="sim_time"/>
     <define name="USE_WIND" value="1"/>
-    <uniform name="windData" value="1.0 1.0"/>
+    <uniform instanced="1" blockName="MaterialUBO" name="windData[0]" value="1.0 1.0"/>
 
 	<required_texture name="baseTex"/>
 	<required_texture name="specTex" define="USE_SPECULAR_MAP"/>
diff --git a/binaries/data/mods/public/art/materials/waterfall.xml b/binaries/data/mods/public/art/materials/waterfall.xml
index 112f61e..ce4825e 100644
--- a/binaries/data/mods/public/art/materials/waterfall.xml
+++ b/binaries/data/mods/public/art/materials/waterfall.xml
@@ -5,8 +5,8 @@
     <renderquery name="sim_time"/>
     <uniform name="translation" value="0.0 -0.4"/>
     
-    <uniform name="specularPower" value="16.0"/>
-    <uniform name="specularColor" value="1.0 1.0 1.0"/>
+    <uniform instanced="1" blockName="MaterialUBO" name="specularPower[0]" value="16.0"/>
+    <uniform instanced="1" blockName="MaterialUBO" name="specularColor[0]" value="1.0 1.0 1.0"/>
 
 	<required_texture name="baseTex"/>
 </material>
diff --git a/binaries/data/mods/public/shaders/glsl/model_common.fs b/binaries/data/mods/public/shaders/glsl/model_common.fs
index 2005454..b8e6d4f 100644
--- a/binaries/data/mods/public/shaders/glsl/model_common.fs
+++ b/binaries/data/mods/public/shaders/glsl/model_common.fs
@@ -1,4 +1,35 @@
-#version 120
+#version 430
+
+const int MAX_INSTANCES = 2000;
+const int MAX_MATERIALS = 64;
+
+in VS_OUT
+{
+  flat uint drawID;
+} fs_in;
+
+out vec4 fragColor;
+
+layout(shared) uniform FrameUBO
+{
+	vec4 sim_time;
+
+	mat4 transform;
+	vec3 cameraPos;
+
+	mat4 shadowTransform;
+	vec4 shadowScale;
+
+	vec3 ambient;	// only used in fragment shader
+	vec3 sunColor;
+	vec3 sunDir;
+
+	vec3 fogColor;	// only used in fragment shader
+	vec2 fogParams;	// only used in fragment shader
+
+	vec2 losTransform;
+
+} frame;
 
 uniform sampler2D baseTex;
 uniform sampler2D losTex;
@@ -7,61 +38,85 @@ uniform sampler2D normTex;
 uniform sampler2D specTex;
 
 #if USE_SHADOW
-  varying vec4 v_shadow;
+  in vec4 v_shadow;
   #if USE_SHADOW_SAMPLER
     uniform sampler2DShadow shadowTex;
-    #if USE_SHADOW_PCF
-      uniform vec4 shadowScale;
-    #endif
+//    #if USE_SHADOW_PCF
+//      uniform vec4 shadowScale;
+//    #endif
   #else
     uniform sampler2D shadowTex;
   #endif
 #endif
 
-#if USE_OBJECTCOLOR
-  uniform vec3 objectColor;
-#else
-#if USE_PLAYERCOLOR
-  uniform vec3 playerColor;
-#endif
-#endif
+// TODO: make these conditional again (in some way...)
+layout(shared) buffer ModelUBO
+{
+  uint modelId[MAX_INSTANCES];
+  //uint materialID[MAX_INSTANCES];
+  mat4 instancingTransform[MAX_INSTANCES];
+  //#if USE_OBJECTCOLOR
+  //  vec3 objectColor[MAX_INSTANCES];
+  //#else
+  //#if USE_PLAYERCOLOR
+  //  vec4 playerColor[MAX_INSTANCES];
+  //#endif
+  //#endif
+  //vec3 shadingColor[MAX_INSTANCES];
+} model;
+
+layout(shared) buffer MaterialIDBlock
+{
+  uint materialID[];
+};
+
+layout(shared) buffer PlayerColorBlock
+{
+  vec4 playerColor[];
+};
 
-uniform vec3 shadingColor;
-uniform vec3 ambient;
-uniform vec3 sunColor;
-uniform vec3 sunDir;
+layout(shared) buffer ShadingColorBlock
+{
+  vec3 shadingColor[];
+};
 
-uniform vec3 fogColor;
-uniform vec2 fogParams;
+layout(shared) buffer MaterialUBO
+{
 
-varying vec4 v_lighting;
-varying vec2 v_tex;
-varying vec2 v_los;
+//#if USE_SPECULAR
+  float specularPower[MAX_MATERIALS];
+  vec3 specularColor[MAX_MATERIALS];
+//#endif
 
-#if (USE_INSTANCING || USE_GPU_SKINNING) && USE_AO
-  varying vec2 v_tex2;
-#endif
+//#if USE_NORMAL_MAP || USE_SPECULAR_MAP || USE_PARALLAX || USE_AO
+  vec4 effectSettings[MAX_MATERIALS];
+//#endif
 
-#if USE_SPECULAR
-  uniform float specularPower;
-  uniform vec3 specularColor;
-#endif
+  vec3 objectColor[MAX_MATERIALS];
 
-#if USE_NORMAL_MAP || USE_SPECULAR_MAP || USE_PARALLAX || USE_AO
-  uniform vec4 effectSettings;
+  vec4 windData[MAX_MATERIALS];
+
+} material;
+
+in vec4 v_lighting;
+in vec2 v_tex;
+in vec2 v_los;
+
+#if (USE_INSTANCING || USE_GPU_SKINNING) && USE_AO
+  in vec2 v_tex2;
 #endif
 
 #if USE_SPECULAR || USE_NORMAL_MAP || USE_SPECULAR_MAP || USE_PARALLAX
-  varying vec4 v_normal;
+  in vec4 v_normal;
   #if (USE_INSTANCING || USE_GPU_SKINNING) && (USE_NORMAL_MAP || USE_PARALLAX)
-    varying vec4 v_tangent;
-    //varying vec3 v_bitangent;
+    in vec4 v_tangent;
+    //in vec3 v_bitangent;
   #endif
   #if USE_SPECULAR || USE_SPECULAR_MAP
-    varying vec3 v_half;
+    in vec3 v_half;
   #endif
   #if (USE_INSTANCING || USE_GPU_SKINNING) && USE_PARALLAX
-    varying vec3 v_eyeVec;
+    in vec3 v_eyeVec;
   #endif
 #endif
 
@@ -70,24 +125,24 @@ float get_shadow()
   float shadowBias = 0.003;
   #if USE_SHADOW && !DISABLE_RECEIVE_SHADOWS
     float biasedShdwZ = v_shadow.z - shadowBias;
-    #if USE_SHADOW_SAMPLER
+    //#if USE_SHADOW_SAMPLER
       #if USE_SHADOW_PCF
         vec2 offset = fract(v_shadow.xy - 0.5);
         vec4 size = vec4(offset + 1.0, 2.0 - offset);
-        vec4 weight = (vec4(1.0, 1.0, -0.5, -0.5) + (v_shadow.xy - 0.5*offset).xyxy) * shadowScale.zwzw;
+        vec4 weight = (vec4(1.0, 1.0, -0.5, -0.5) + (v_shadow.xy - 0.5*offset).xyxy) * frame.shadowScale.zwzw;
         return (1.0/9.0)*dot(size.zxzx*size.wwyy,
-          vec4(shadow2D(shadowTex, vec3(weight.zw, biasedShdwZ)).r,
-               shadow2D(shadowTex, vec3(weight.xw, biasedShdwZ)).r,
-               shadow2D(shadowTex, vec3(weight.zy, biasedShdwZ)).r,
-               shadow2D(shadowTex, vec3(weight.xy, biasedShdwZ)).r));
+          vec4(texture(shadowTex, vec3(weight.zw, biasedShdwZ)).r,
+               texture(shadowTex, vec3(weight.xw, biasedShdwZ)).r,
+               texture(shadowTex, vec3(weight.zy, biasedShdwZ)).r,
+               texture(shadowTex, vec3(weight.xy, biasedShdwZ)).r));
       #else
-        return shadow2D(shadowTex, vec3(v_shadow.xy, biasedShdwZ)).r;
+        return texture(shadowTex, vec3(v_shadow.xy, biasedShdwZ)).r;
       #endif
-    #else
-      if (biasedShdwZ >= 1.0)
-        return 1.0;
-      return (biasedShdwZ < texture2D(shadowTex, v_shadow.xy).x ? 1.0 : 0.0);
-    #endif
+    //#else
+    //  if (biasedShdwZ >= 1.0)
+    //    return 1.0;
+    //  return (biasedShdwZ < texture2D(shadowTex, v_shadow.xy).x ? 1.0 : 0.0);
+    //#endif
   #else
     return 1.0;
   #endif
@@ -95,8 +150,8 @@ float get_shadow()
 
 vec3 get_fog(vec3 color)
 {
-  float density = fogParams.x;
-  float maxFog = fogParams.y;
+  float density = frame.fogParams.x;
+  float maxFog = frame.fogParams.y;
 
   const float LOG2 = 1.442695;
   float z = gl_FragCoord.z / gl_FragCoord.w;
@@ -106,11 +161,13 @@ vec3 get_fog(vec3 color)
 
   fogFactor = clamp(fogFactor, 0.0, 1.0);
 
-  return mix(fogColor, color, fogFactor);
+  return mix(frame.fogColor, color, fogFactor);
 }
 
 void main()
 {
+  const uint materialIDVal = materialID[model.modelId[fs_in.drawID]];
+
   vec2 coord = v_tex;
 
   #if (USE_INSTANCING || USE_GPU_SKINNING) && (USE_PARALLAX || USE_NORMAL_MAP)
@@ -127,7 +184,7 @@ void main()
 
     vec2 move;
     float height = 1.0;
-    float scale = effectSettings.z;
+    float scale = material.effectSettings[materialIDVal].z;
 	  
     int iter = int(min(20, 25.0 - dist/10.0));
 	
@@ -164,19 +221,19 @@ void main()
   #endif
 
   #if USE_TRANSPARENT
-    gl_FragColor.a = tex.a;
+    fragColor.a = tex.a;
   #else
-    gl_FragColor.a = 1.0;
+    fragColor.a = 1.0;
   #endif
   
   vec3 texdiffuse = tex.rgb;
 
   // Apply-coloring based on texture alpha
   #if USE_OBJECTCOLOR
-    texdiffuse *= mix(objectColor, vec3(1.0, 1.0, 1.0), tex.a);
+    texdiffuse *= mix(material.objectColor[materialIDVal], vec3(1.0, 1.0, 1.0), tex.a);
   #else
   #if USE_PLAYERCOLOR
-    texdiffuse *= mix(playerColor, vec3(1.0, 1.0, 1.0), tex.a);
+    texdiffuse *= mix(playerColor[model.modelId[fs_in.drawID]].rgb, vec3(1.0, 1.0, 1.0), tex.a);
   #endif
   #endif
 
@@ -188,8 +245,8 @@ void main()
     vec3 ntex = texture2D(normTex, coord).rgb * 2.0 - 1.0;
     ntex.y = -ntex.y;
     normal = normalize(tbn * ntex);
-    vec3 bumplight = max(dot(-sunDir, normal), 0.0) * sunColor;
-    vec3 sundiffuse = (bumplight - v_lighting.rgb) * effectSettings.x + v_lighting.rgb;
+    vec3 bumplight = max(dot(-frame.sunDir, normal), 0.0) * frame.sunColor;
+    vec3 sundiffuse = (bumplight - v_lighting.rgb) * material.effectSettings[materialIDVal].x + v_lighting.rgb;
   #else
     vec3 sundiffuse = v_lighting.rgb;
   #endif
@@ -202,20 +259,20 @@ void main()
       vec4 s = texture2D(specTex, coord);
       specCol = s.rgb;
       specular.a = s.a;
-      specPow = effectSettings.y;
+      specPow = material.effectSettings[materialIDVal].y;
     #else
-      specCol = specularColor;
-      specPow = specularPower;
+      specCol = material.specularColor[materialIDVal];
+      specPow = material.specularPower[materialIDVal];
     #endif
-    specular.rgb = sunColor * specCol * pow(max(0.0, dot(normalize(normal), v_half)), specPow);
+    specular.rgb = frame.sunColor * specCol * pow(max(0.0, dot(normalize(normal), v_half)), specPow);
   #endif
 
   vec3 color = (texdiffuse * sundiffuse + specular.rgb) * get_shadow();
-  vec3 ambColor = texdiffuse * ambient;
+  vec3 ambColor = texdiffuse * frame.ambient;
 
   #if (USE_INSTANCING || USE_GPU_SKINNING) && USE_AO
     vec3 ao = texture2D(aoTex, v_tex2).rrr;
-    ao = mix(vec3(1.0), ao * 2.0, effectSettings.w);
+    ao = mix(vec3(1.0), ao * 2.0, material.effectSettings[materialIDVal].w);
     ambColor *= ao;
   #endif
 
@@ -233,7 +290,7 @@ void main()
     color *= los;
   #endif
 
-  color *= shadingColor;
+  color *= shadingColor[model.modelId[fs_in.drawID]];
 
-  gl_FragColor.rgb = color;
+  fragColor.rgb = color;
 }
diff --git a/binaries/data/mods/public/shaders/glsl/model_common.vs b/binaries/data/mods/public/shaders/glsl/model_common.vs
index f4e6464..2ad4f4b 100644
--- a/binaries/data/mods/public/shaders/glsl/model_common.vs
+++ b/binaries/data/mods/public/shaders/glsl/model_common.vs
@@ -1,67 +1,122 @@
-#version 120
-
-uniform mat4 transform;
-uniform vec3 cameraPos;
-#ifdef GL_ES
-uniform mediump vec3 sunDir;
-uniform mediump vec3 sunColor;
-#else
-uniform vec3 sunDir;
-uniform vec3 sunColor;
-#endif
-uniform vec2 losTransform;
-uniform mat4 shadowTransform;
-uniform mat4 instancingTransform;
+#version 430
 
-#if USE_SHADOW_SAMPLER && USE_SHADOW_PCF
-  uniform vec4 shadowScale;
-#endif
+const int MAX_INSTANCES = 2000;
+const int MAX_MATERIALS = 64;
+layout (location = 15) in uint drawID;
 
-#if USE_WIND
-  uniform vec4 sim_time;
-  uniform vec4 windData;
-#endif
+out VS_OUT
+{
+    flat uint drawID;
+} vs_out;
+
+ 
+layout(shared) uniform FrameUBO
+{
+	vec4 sim_time;
+
+	mat4 transform;
+	vec3 cameraPos;
 
-varying vec4 v_lighting;
-varying vec2 v_tex;
-varying vec2 v_los;
+	mat4 shadowTransform;
+	vec4 shadowScale;
+
+	vec3 ambient;	// only used in fragment shader
+	vec3 sunColor;
+	vec3 sunDir;
+
+	vec3 fogColor;	// only used in fragment shader
+	vec2 fogParams;	// only used in fragment shader
+
+	vec2 losTransform;
+
+} frame;
+
+// TODO: make these conditional again (in some way...)
+layout(shared) buffer ModelUBO
+{
+  uint modelId[MAX_INSTANCES];
+  //uint materialID[MAX_INSTANCES];
+  mat4 instancingTransform[MAX_INSTANCES];
+  //#if USE_OBJECTCOLOR
+  //  vec3 objectColor[MAX_INSTANCES];
+  //#else
+  //#if USE_PLAYERCOLOR
+  //  vec4 playerColor[MAX_INSTANCES];
+  //#endif
+  //#endif
+  //vec3 shadingColor[MAX_INSTANCES];
+} model;
+
+layout(shared) buffer MaterialIDBlock
+{
+  uint materialID[];
+};
+
+layout(shared) buffer MaterialUBO
+{
+
+//#if USE_SPECULAR
+  float specularPower[MAX_MATERIALS];
+  vec3 specularColor[MAX_MATERIALS];
+//#endif
+
+//#if USE_NORMAL_MAP || USE_SPECULAR_MAP || USE_PARALLAX || USE_AO
+  vec4 effectSettings[MAX_MATERIALS];
+//#endif
+
+  vec3 objectColor[MAX_MATERIALS];
+
+  vec4 windData[MAX_MATERIALS];
+
+} material;
+
+
+out vec4 v_lighting;
+out vec2 v_tex;
+out vec2 v_los;
 
 #if USE_SHADOW
-  varying vec4 v_shadow;
+  out vec4 v_shadow;
 #endif
 
 #if (USE_INSTANCING || USE_GPU_SKINNING) && USE_AO
-  varying vec2 v_tex2;
+  out vec2 v_tex2;
 #endif
 
 #if USE_SPECULAR || USE_NORMAL_MAP || USE_SPECULAR_MAP || USE_PARALLAX
-  varying vec4 v_normal;
+  out vec4 v_normal;
   #if (USE_INSTANCING || USE_GPU_SKINNING) && (USE_NORMAL_MAP || USE_PARALLAX)
-    varying vec4 v_tangent;
+    out vec4 v_tangent;
     //varying vec3 v_bitangent;
   #endif
   #if USE_SPECULAR || USE_SPECULAR_MAP
-    varying vec3 v_half;
+    out vec3 v_half;
   #endif
   #if (USE_INSTANCING || USE_GPU_SKINNING) && USE_PARALLAX
-    varying vec3 v_eyeVec;
+    out vec3 v_eyeVec;
   #endif
 #endif
 
-attribute vec3 a_vertex;
-attribute vec3 a_normal;
+in vec3 a_vertex;
+in vec3 a_normal;
 #if (USE_INSTANCING || USE_GPU_SKINNING)
-  attribute vec4 a_tangent;
+  in vec4 a_tangent;
 #endif
-attribute vec2 a_uv0;
-attribute vec2 a_uv1;
+in vec2 a_uv0;
+in vec2 a_uv1;
 
 #if USE_GPU_SKINNING
   const int MAX_INFLUENCES = 4;
   const int MAX_BONES = 64;
-  uniform mat4 skinBlendMatrices[MAX_BONES];
-  attribute vec4 a_skinJoints;
-  attribute vec4 a_skinWeights;
+
+  // skindBlendMatrices could be set to a fixed size (MAX_INSTANCES * MAX_BONES), but the Nvidia drivers have a bug
+  // that causes terribly long (tens of minutes) linking times when large fixed size SSBOs are used.
+  buffer GPUSkinningUBO 
+  {
+    mat4 skinBlendMatrices[]; 
+  } gpuSkinning;
+  in vec4 a_skinJoints;
+  in vec4 a_skinWeights;
 #endif
 
 
@@ -74,27 +129,53 @@ vec4 fakeCos(vec4 x)
 
 void main()
 {
+  const uint materialIDVal = materialID[model.modelId[drawID]];
+
+//mat4 model.instancingTransform[drawID] = mat4(1.0, 0,   0,   0,
+//                        0  , 1.0, 0,   0,
+//                        0  , 0,   1.0, 0,
+//                        200, 200, 300, 1.0);
+
+  vs_out.drawID = drawID;
+
+#if 0
+  if (vec2(1.0, 1.0) != material.windData[materialIDVal].xy)
+  {
+	const vec4 vertices[] = vec4[](vec4( 0.25+materialIDVal*0.05, -0.25, 0.5, 1.0),
+                                       vec4( 0.25+materialIDVal*0.05,  0.25, 0.5, 1.0),
+                                       vec4(-0.25+materialIDVal*0.05, -0.25, 0.5, 1.0));
+	//const vec4 vertices[] = vec4[](vec4( 0.25, -0.25, 0.1, 1.0),
+        //                               vec4( 0.25,  0.25, 0.1, 1.0),
+        //                               vec4(-0.25, -0.25, 0.1, 1.0));
+	if (gl_VertexID < 3)
+	{
+        	gl_Position = vertices[gl_VertexID] * mat4(1.0); //model.instancingTransform[drawID];
+	}
+	return;
+  }
+#endif
+
   #if USE_GPU_SKINNING
     vec3 p = vec3(0.0);
     vec3 n = vec3(0.0);
     for (int i = 0; i < MAX_INFLUENCES; ++i) {
       int joint = int(a_skinJoints[i]);
       if (joint != 0xff) {
-        mat4 m = skinBlendMatrices[joint];
+        mat4 m = gpuSkinning.skinBlendMatrices[drawID * MAX_BONES + joint];
         p += vec3(m * vec4(a_vertex, 1.0)) * a_skinWeights[i];
         n += vec3(m * vec4(a_normal, 0.0)) * a_skinWeights[i];
       }
     }
-    vec4 position = instancingTransform * vec4(p, 1.0);
-    mat3 normalMatrix = mat3(instancingTransform[0].xyz, instancingTransform[1].xyz, instancingTransform[2].xyz);
+    vec4 position = model.instancingTransform[drawID] * vec4(p, 1.0);
+    mat3 normalMatrix = mat3(model.instancingTransform[drawID][0].xyz, model.instancingTransform[drawID][1].xyz, model.instancingTransform[drawID][2].xyz);
     vec3 normal = normalMatrix * normalize(n);
     #if (USE_NORMAL_MAP || USE_PARALLAX)
       vec3 tangent = normalMatrix * a_tangent.xyz;
     #endif
   #else
   #if (USE_INSTANCING)
-    vec4 position = instancingTransform * vec4(a_vertex, 1.0);
-    mat3 normalMatrix = mat3(instancingTransform[0].xyz, instancingTransform[1].xyz, instancingTransform[2].xyz);
+    vec4 position = model.instancingTransform[drawID] * vec4(a_vertex, 1.0);
+    mat3 normalMatrix = mat3(model.instancingTransform[drawID][0].xyz, model.instancingTransform[drawID][1].xyz, model.instancingTransform[drawID][2].xyz);
     vec3 normal = normalMatrix * a_normal;
     #if (USE_NORMAL_MAP || USE_PARALLAX)
       vec3 tangent = normalMatrix * a_tangent.xyz;
@@ -107,10 +188,10 @@ void main()
 
 
   #if USE_WIND
-    vec2 wind = windData.xy;
+    vec2 wind = material.windData[materialIDVal].xy;
 
     // fractional part of model position, clamped to >.4
-    vec4 modelPos = instancingTransform[3];
+    vec4 modelPos = model.instancingTransform[drawID][3];
     modelPos = fract(modelPos);
     modelPos = clamp(modelPos, 0.4, 1.0);
 
@@ -120,9 +201,9 @@ void main()
     vec4 cosVec;
     // these determine the speed of the wind's "cosine" waves.
     cosVec.w = 0.0;
-    cosVec.x = sim_time.x * modelPos[0] + position.x;
-    cosVec.y = sim_time.x * modelPos[2] / 3.0 + instancingTransform[3][0];
-    cosVec.z = sim_time.x * abswind / 4.0 + position.z;
+    cosVec.x = frame.sim_time.x * modelPos[0] + position.x;
+    cosVec.y = frame.sim_time.x * modelPos[2] / 3.0 + model.instancingTransform[drawID][3][0];
+    cosVec.z = frame.sim_time.x * abswind / 4.0 + position.z;
 
     // calculate "cosines" in parallel, using a smoothed triangle wave
     cosVec = fakeCos(cosVec);
@@ -140,7 +221,7 @@ void main()
   #endif
 
 
-  gl_Position = transform * position;
+  gl_Position = frame.transform * position;
 
   #if USE_SPECULAR || USE_NORMAL_MAP || USE_SPECULAR_MAP || USE_PARALLAX
     v_normal.xyz = normal;
@@ -154,9 +235,9 @@ void main()
     #endif
 
     #if USE_SPECULAR || USE_SPECULAR_MAP || USE_PARALLAX
-      vec3 eyeVec = cameraPos.xyz - position.xyz;
+      vec3 eyeVec = frame.cameraPos.xyz - position.xyz;
       #if USE_SPECULAR || USE_SPECULAR_MAP     
-        vec3 sunVec = -sunDir;
+        vec3 sunVec = -frame.sunDir;
         v_half = normalize(sunVec + normalize(eyeVec));
       #endif
       #if (USE_INSTANCING || USE_GPU_SKINNING) && USE_PARALLAX
@@ -165,7 +246,7 @@ void main()
     #endif
   #endif
   
-  v_lighting.xyz = max(0.0, dot(normal, -sunDir)) * sunColor;
+  v_lighting.xyz = max(0.0, dot(normal, -frame.sunDir)) * frame.sunColor;
 
   v_tex = a_uv0;
 
@@ -174,11 +255,12 @@ void main()
   #endif
 
   #if USE_SHADOW
-    v_shadow = shadowTransform * position;
+    v_shadow = frame.shadowTransform * position;
     #if USE_SHADOW_SAMPLER && USE_SHADOW_PCF
-      v_shadow.xy *= shadowScale.xy;
+      v_shadow.xy *= frame.shadowScale.xy;
     #endif  
   #endif
 
-  v_los = position.xz * losTransform.x + losTransform.y;
+  v_los = position.xz * frame.losTransform.x + frame.losTransform.y;
+
 }
diff --git a/binaries/data/mods/public/shaders/glsl/model_common.xml b/binaries/data/mods/public/shaders/glsl/model_common.xml
index 0eb6fef..bb07d1e 100644
--- a/binaries/data/mods/public/shaders/glsl/model_common.xml
+++ b/binaries/data/mods/public/shaders/glsl/model_common.xml
@@ -10,6 +10,7 @@
         <attrib name="a_normal" semantics="gl_Normal"/>
         <attrib name="a_uv0" semantics="gl_MultiTexCoord0"/>
 	<attrib name="a_uv1" semantics="gl_MultiTexCoord1" if="USE_AO"/>
+	<attrib name="a_drawId" semantics="gl_MultiTexCoord7"/>
         <attrib name="a_skinJoints" semantics="CustomAttribute0" if="USE_GPU_SKINNING"/>
         <attrib name="a_skinWeights" semantics="CustomAttribute1" if="USE_GPU_SKINNING"/>
 	<attrib name="a_tangent" semantics="CustomAttribute2" if="USE_INSTANCING || USE_GPU_SKINNING"/>
diff --git a/binaries/data/mods/public/shaders/glsl/model_solid.xml b/binaries/data/mods/public/shaders/glsl/model_solid.xml
index 8faa394..4e67e89 100644
--- a/binaries/data/mods/public/shaders/glsl/model_solid.xml
+++ b/binaries/data/mods/public/shaders/glsl/model_solid.xml
@@ -4,6 +4,7 @@
     <vertex file="glsl/model_common.vs">
         <stream name="pos"/>
         <attrib name="a_vertex" semantics="gl_Vertex"/>
+	<attrib name="a_drawId" semantics="gl_MultiTexCoord7"/>
         <attrib name="a_skinJoints" semantics="CustomAttribute0" if="USE_GPU_SKINNING"/>
         <attrib name="a_skinWeights" semantics="CustomAttribute1" if="USE_GPU_SKINNING"/>
     </vertex>
diff --git a/binaries/data/mods/public/shaders/glsl/model_solid_player.xml b/binaries/data/mods/public/shaders/glsl/model_solid_player.xml
index 107bd69..3ed078a 100644
--- a/binaries/data/mods/public/shaders/glsl/model_solid_player.xml
+++ b/binaries/data/mods/public/shaders/glsl/model_solid_player.xml
@@ -4,6 +4,7 @@
     <vertex file="glsl/model_common.vs">
         <stream name="pos"/>
         <attrib name="a_vertex" semantics="gl_Vertex"/>
+	<attrib name="a_drawId" semantics="gl_MultiTexCoord7"/>
         <attrib name="a_skinJoints" semantics="CustomAttribute0" if="USE_GPU_SKINNING"/>
         <attrib name="a_skinWeights" semantics="CustomAttribute1" if="USE_GPU_SKINNING"/>
     </vertex>
diff --git a/binaries/data/mods/public/shaders/glsl/model_solid_tex.xml b/binaries/data/mods/public/shaders/glsl/model_solid_tex.xml
index d6dafb4..c68fe77 100644
--- a/binaries/data/mods/public/shaders/glsl/model_solid_tex.xml
+++ b/binaries/data/mods/public/shaders/glsl/model_solid_tex.xml
@@ -6,6 +6,7 @@
         <stream name="uv0"/>
         <attrib name="a_vertex" semantics="gl_Vertex"/>
         <attrib name="a_uv0" semantics="gl_MultiTexCoord0"/>
+	<attrib name="a_drawId" semantics="gl_MultiTexCoord7"/>
         <attrib name="a_skinJoints" semantics="CustomAttribute0" if="USE_GPU_SKINNING"/>
         <attrib name="a_skinWeights" semantics="CustomAttribute1" if="USE_GPU_SKINNING"/>
     </vertex>
diff --git a/binaries/data/mods/public/shaders/glsl/solid.fs b/binaries/data/mods/public/shaders/glsl/solid.fs
index f256cee..a11928e 100644
--- a/binaries/data/mods/public/shaders/glsl/solid.fs
+++ b/binaries/data/mods/public/shaders/glsl/solid.fs
@@ -1,8 +1,10 @@
-#version 110
+#version 430
+
+out vec4 fragColor;
 
 uniform vec4 color;
 
 void main()
 {
-  gl_FragColor = color;
+  fragColor = color;
 }
diff --git a/binaries/data/mods/public/shaders/glsl/solid_player.fs b/binaries/data/mods/public/shaders/glsl/solid_player.fs
index d65ffdd..c919356 100644
--- a/binaries/data/mods/public/shaders/glsl/solid_player.fs
+++ b/binaries/data/mods/public/shaders/glsl/solid_player.fs
@@ -1,13 +1,65 @@
-#version 110
+#version 430
 
-uniform vec4 playerColor;
-uniform vec3 fogColor;
-uniform vec2 fogParams;
+const int MAX_INSTANCES = 2000;
+const int MAX_MATERIALS = 64;
+
+in VS_OUT
+{
+  flat uint drawID;
+} fs_in;
+
+out vec4 fragColor;
+
+uniform FrameUBO
+{
+	vec4 sim_time;
+
+	mat4 transform;
+	vec3 cameraPos;
+
+	mat4 shadowTransform;
+	vec4 shadowScale;
+
+	vec3 ambient;	// only used in fragment shader
+	vec3 sunColor;
+	vec3 sunDir;
+
+	vec3 fogColor;	// only used in fragment shader
+	vec2 fogParams;	// only used in fragment shader
+
+	vec2 losTransform;
+
+} frame;
+
+layout(shared) buffer ModelUBO
+{
+  uint modelId[MAX_INSTANCES];
+  //uint materialID[MAX_INSTANCES];
+  mat4 instancingTransform[MAX_INSTANCES];
+  //#if USE_OBJECTCOLOR
+  //  vec3 objectColor[MAX_INSTANCES];
+  //#else
+  //#if USE_PLAYERCOLOR
+  //  vec4 playerColor[MAX_INSTANCES];
+  //#endif
+  //#endif
+  //vec3 shadingColor[MAX_INSTANCES];
+} model;
+
+layout(shared) buffer PlayerColorBlock
+{
+  vec4 playerColor[];
+};
+
+layout(shared) buffer MaterialIDBlock
+{
+  uint materialID[];
+};
 
 vec3 get_fog(vec3 color)
 {
-	float density = fogParams.x;
-	float maxFog = fogParams.y;
+	float density = frame.fogParams.x;
+	float maxFog = frame.fogParams.y;
 	
 	const float LOG2 = 1.442695;
 	float z = gl_FragCoord.z / gl_FragCoord.w;
@@ -17,10 +69,11 @@ vec3 get_fog(vec3 color)
 	
 	fogFactor = clamp(fogFactor, 0.0, 1.0);
 	
-	return mix(fogColor, color, fogFactor);
+	return mix(frame.fogColor, color, fogFactor);
 }
 
 void main()
 {
-	gl_FragColor = vec4(get_fog(playerColor.rgb),playerColor.a);
+	const uint materialIDVal = materialID[model.modelId[fs_in.drawID]];
+	fragColor = vec4(get_fog(playerColor[materialIDVal].rgb), playerColor[materialIDVal].a);
 }
diff --git a/binaries/data/mods/public/shaders/glsl/solid_tex.fs b/binaries/data/mods/public/shaders/glsl/solid_tex.fs
index 4ad2195..3e0871f 100644
--- a/binaries/data/mods/public/shaders/glsl/solid_tex.fs
+++ b/binaries/data/mods/public/shaders/glsl/solid_tex.fs
@@ -1,8 +1,10 @@
-#version 110
+#version 430
+
+out vec4 fragColor;
 
 uniform sampler2D baseTex;
 
-varying vec2 v_tex;
+in vec2 v_tex;
 
 void main()
 {
@@ -13,5 +15,5 @@ void main()
       discard;
   #endif
 
-  gl_FragColor = tex;
+  fragColor = tex;
 }
diff --git a/source/graphics/Material.cpp b/source/graphics/Material.cpp
index 7fb0346..d6b9c50 100644
--- a/source/graphics/Material.cpp
+++ b/source/graphics/Material.cpp
@@ -19,10 +19,14 @@
 
 #include "Material.h"
 
+#include "graphics/ShaderBlockUniforms.h"
+#include "UniformBlockManager.h"
+
 static CColor BrokenColor(0.3f, 0.3f, 0.3f, 1.0f);
 
 CMaterial::CMaterial() :
-	m_AlphaBlending(false)
+	m_AlphaBlending(false),
+	m_MaterialId(-1)
 {
 }
 
@@ -48,6 +52,26 @@ void CMaterial::AddStaticUniform(const char* key, const CVector4D& value)
 	m_StaticUniforms.Add(key, value);
 }
 
+void CMaterial::AddStaticBlockUniform(CStrIntern blockName, CStrIntern name, bool isInstanced, const CVector4D& value)
+{
+	m_StaticBlockUniforms.Add(blockName, name, isInstanced, value);
+	
+	if (m_MaterialId == -1)
+		return;
+	
+
+	UniformBlockManager& uniformBlockManager = g_Renderer.GetUniformBlockManager();
+	uniformBlockManager.MaterialModified(m_StaticBlockUniforms, m_MaterialId);
+
+	// TODO: Do this when all uniforms are added?
+}
+
+bool CMaterial::GetBindings()
+{
+	return m_StaticBlockUniforms.GetBindings();
+}
+
+
 void CMaterial::AddSampler(const TextureSampler& texture)
 {
 	m_Samplers.push_back(texture);
diff --git a/source/graphics/Material.h b/source/graphics/Material.h
index f4d687f..c5b5b3a 100644
--- a/source/graphics/Material.h
+++ b/source/graphics/Material.h
@@ -24,6 +24,9 @@
 #include "ps/CStrIntern.h"
 #include "ps/Shapes.h"
 #include "simulation2/helpers/Player.h"
+#include "graphics/ShaderBlockUniforms.h"
+
+//class CShaderBlockUniforms;
 
 class CMaterial
 {
@@ -66,9 +69,17 @@ public:
 
 	const CShaderConditionalDefines& GetConditionalDefines() const { return m_ConditionalDefines; }
 
+	// single uniforms in the default block (temporary for backwards compatibility with older code and shaders)
 	void AddStaticUniform(const char* key, const CVector4D& value);
 	const CShaderUniforms& GetStaticUniforms() const { return m_StaticUniforms; }
 
+	// uniforms in blocks
+	void AddStaticBlockUniform(CStrIntern blockName, CStrIntern name, bool isInstanced, const CVector4D& value);
+	CShaderBlockUniforms& GetStaticBlockUniforms() { return m_StaticBlockUniforms; }
+	
+	// Requires UniformBlockManager to be initialized and all available blocks to be added
+	bool GetBindings();
+
 	void AddSampler(const TextureSampler& texture);
 	const SamplersVector& GetSamplers() const { return m_Samplers; }
 	
@@ -80,6 +91,9 @@ public:
 
 	// Must be called after all AddShaderDefine and AddConditionalDefine
 	void RecomputeCombinedShaderDefines();
+	
+	int GetId() const { return m_MaterialId; }
+	void SetId(int id) { m_MaterialId = id; } // TODO: Make this private and use fried classes?
 
 private:
 	
@@ -94,10 +108,14 @@ private:
 	CShaderDefines m_ShaderDefines;
 	CShaderConditionalDefines m_ConditionalDefines;
 	std::vector<CShaderDefines> m_CombinedShaderDefines;
+	// TODO: try to reduce compile time when CShaderBlockUniforms changes using the pimpl idom or similar
+	CShaderBlockUniforms m_StaticBlockUniforms;
 	CShaderUniforms m_StaticUniforms;
 	CShaderRenderQueries m_RenderQueries;
 
 	bool m_AlphaBlending;
+	
+	int m_MaterialId;
 };
 
 #endif
diff --git a/source/graphics/MaterialManager.cpp b/source/graphics/MaterialManager.cpp
index 74462a0..b0ac2c9 100644
--- a/source/graphics/MaterialManager.cpp
+++ b/source/graphics/MaterialManager.cpp
@@ -28,9 +28,12 @@
 #include "ps/PreprocessorWrapper.h"
 #include "ps/XML/Xeromyces.h"
 #include "renderer/Renderer.h"
+#include "graphics/UniformBlockManager.h"
 
 #include <sstream>
 
+int CMaterialManager::m_NextFreeMaterialID = 0;
+
 CMaterialManager::CMaterialManager()
 {
 	qualityLevel = 5.0;
@@ -61,6 +64,7 @@ CMaterial CMaterialManager::LoadMaterial(const VfsPath& pathname)
 	EL(define);
 	EL(shader);
 	EL(uniform);
+	EL(blockuniform);
 	EL(renderquery);
 	EL(required_texture);
 	EL(conditional_define);
@@ -70,6 +74,8 @@ CMaterial CMaterialManager::LoadMaterial(const VfsPath& pathname)
 	AT(quality);
 	AT(material);
 	AT(name);
+	AT(blockname);
+	AT(instanced);
 	AT(value);
 	AT(type);
 	AT(min);
@@ -79,14 +85,18 @@ CMaterial CMaterialManager::LoadMaterial(const VfsPath& pathname)
 	#undef EL
 
 	CMaterial material;
+	material.SetId(m_NextFreeMaterialID++);
 
 	XMBElement root = xeroFile.GetRoot();
 	
 	CPreprocessorWrapper preprocessor;
 	preprocessor.AddDefine("CFG_FORCE_ALPHATEST", g_Renderer.m_Options.m_ForceAlphaTest ? "1" : "0");
 	
-	CVector4D vec(qualityLevel,0,0,0);
-	material.AddStaticUniform("qualityLevel", vec);
+	//CVector4D vec(qualityLevel,0,0,0);
+	//material.AddStaticUniform("qualityLevel", vec);
+	
+	//CVector4D vec(qualityLevel,0,0,0);
+	//material.AddStaticUniform(CStrIntern("UnusedBlock"), CStrIntern("qualityLevel"), false, vec);
 
 	XERO_ITER_EL(root, node)
 	{
@@ -181,7 +191,31 @@ CMaterial CMaterialManager::LoadMaterial(const VfsPath& pathname)
 			CVector4D vec;
 			str >> vec.X >> vec.Y >> vec.Z >> vec.W;
 			material.AddStaticUniform(attrs.GetNamedItem(at_name).c_str(), vec);
+			
+			CStr blockName = attrs.GetNamedItem(at_blockname);
+			if (!blockName.empty())
+			{
+							bool isInstanced = attrs.GetNamedItem(at_instanced).ToInt();
+			
+							material.AddStaticBlockUniform(CStrIntern(blockName),
+			                  CStrIntern(attrs.GetNamedItem(at_name).c_str()),
+							  isInstanced,
+			                  vec);
+			}			                  
 		}
+		/*
+		else if (token == el_blockuniform)
+		{
+			std::stringstream str(attrs.GetNamedItem(at_value));
+			CVector4D vec;
+			str >> vec.X >> vec.Y >> vec.Z >> vec.W;
+			bool isInstanced = attrs.GetNamedItem(at_instanced).ToInt();
+			
+			material.AddStaticBlockUniform(CStrIntern(attrs.GetNamedItem(at_blockname)),
+			                  CStrIntern(attrs.GetNamedItem(at_name).c_str()),
+							  isInstanced,
+			                  vec);
+		}*/
 		else if (token == el_renderquery)
 		{
 			material.AddRenderQuery(attrs.GetNamedItem(at_name).c_str());
@@ -196,6 +230,9 @@ CMaterial CMaterialManager::LoadMaterial(const VfsPath& pathname)
 
 	material.RecomputeCombinedShaderDefines();
 
+	std::cout << "MaterialLoaded: " << pathname.string8().c_str() << "   ID: " << material.GetId() << std::endl;
 	m_Materials[pathname] = material;
+	UniformBlockManager& uniformBlockManager = g_Renderer.GetUniformBlockManager();
+	uniformBlockManager.MaterialAdded(material.GetStaticBlockUniforms(), material.GetId());
 	return material;
 }
diff --git a/source/graphics/MaterialManager.h b/source/graphics/MaterialManager.h
index 3c84698..3d55109 100644
--- a/source/graphics/MaterialManager.h
+++ b/source/graphics/MaterialManager.h
@@ -31,6 +31,9 @@ public:
 private:
 	std::map<VfsPath, CMaterial> m_Materials;
 	float qualityLevel;
+	
+	// TODO: We might want to reuse IDs in cases when we reload materials or stop using them
+	static int m_NextFreeMaterialID;
 };
 
 #endif // INCLUDED_MATERIALMANAGER
diff --git a/source/graphics/Model.cpp b/source/graphics/Model.cpp
index da8d3c1..fab4c77 100644
--- a/source/graphics/Model.cpp
+++ b/source/graphics/Model.cpp
@@ -653,11 +653,6 @@ void CModel::RemoveShadowsRec()
 	}
 }
 
-void CModel::SetMaterial(const CMaterial &material)
-{
-	m_Material = material;
-}
-
 void CModel::SetPlayerID(player_id_t id)
 {
 	CModelAbstract::SetPlayerID(id);
diff --git a/source/graphics/Model.h b/source/graphics/Model.h
index 6f513cd..c1dfaa1 100644
--- a/source/graphics/Model.h
+++ b/source/graphics/Model.h
@@ -97,14 +97,10 @@ public:
 	// get the model's geometry data
 	const CModelDefPtr& GetModelDef() { return m_pModelDef; }
 
-	// set the model's material
-	void SetMaterial(const CMaterial &material);
 	// set the model's player ID, recursively through props
 	void SetPlayerID(player_id_t id);
 	// set the models mod color
 	virtual void SetShadingColor(const CColor& color);
-	// get the model's material
-	CMaterial& GetMaterial() { return m_Material; }
 
 	// set the given animation as the current animation on this model
 	bool SetAnimation(CSkeletonAnim* anim, bool once = false);
@@ -263,8 +259,7 @@ private:
 
 	// object flags
 	int m_Flags;
-	// model's material
-	CMaterial m_Material;
+
 	// pointer to the model's raw 3d data
 	CModelDefPtr m_pModelDef;
 	// object space bounds of model - accounts for bounds of all possible animations
diff --git a/source/graphics/ModelAbstract.cpp b/source/graphics/ModelAbstract.cpp
index 769de5d..28a7ee8 100644
--- a/source/graphics/ModelAbstract.cpp
+++ b/source/graphics/ModelAbstract.cpp
@@ -18,9 +18,37 @@
 #include "precompiled.h"
 
 #include "ModelAbstract.h"
+#include "graphics/UniformBlockManager.h"
 
 #include "ps/CLogger.h"
 
+std::set<int> CModelAbstract::m_FreeIDs;
+int CModelAbstract::m_MaxID = 0;
+
+CModelAbstract::CModelAbstract()
+	: m_Parent(NULL), m_PositionValid(false), m_ShadingColor(1, 1, 1, 1), m_PlayerID(INVALID_PLAYER), 
+	  m_SelectionBoxValid(false), m_CustomSelectionShape(NULL)
+{
+	 m_ID = AcquireID();
+	 UniformBlockManager& uniformBlockManager = g_Renderer.GetUniformBlockManager();
+	 uniformBlockManager.ModelAdded(this);
+}
+
+CModelAbstract::~CModelAbstract()
+{
+	FreeID(m_ID);
+	UniformBlockManager& uniformBlockManager = g_Renderer.GetUniformBlockManager();
+	uniformBlockManager.ModelRemoved(this);
+	delete m_CustomSelectionShape; // allocated and set externally by CCmpVisualActor, but our responsibility to clean up
+}
+
+void CModelAbstract::SetMaterial(const CMaterial &material)
+{
+	m_Material = material;
+	UniformBlockManager& uniformBlockManager = g_Renderer.GetUniformBlockManager();
+	uniformBlockManager.MaterialChanged(this);
+}
+
 const CBoundingBoxOriented& CModelAbstract::GetSelectionBox()
 {
 	if (!m_SelectionBoxValid)
@@ -90,3 +118,17 @@ void CModelAbstract::CalcSelectionBox()
 	}
 	
 }
+
+void CModelAbstract::SetPlayerID(player_id_t id)
+{
+	m_PlayerID = id;
+	UniformBlockManager& uniformBlockManager = g_Renderer.GetUniformBlockManager();
+	uniformBlockManager.PlayerIDChanged(this);
+}
+
+void CModelAbstract::SetShadingColor(const CColor& color) 
+{
+	m_ShadingColor = color;
+	UniformBlockManager& uniformBlockManager = g_Renderer.GetUniformBlockManager();
+	uniformBlockManager.ShadingColorChanged(this);
+}
diff --git a/source/graphics/ModelAbstract.h b/source/graphics/ModelAbstract.h
index 5a98eea..188359a 100644
--- a/source/graphics/ModelAbstract.h
+++ b/source/graphics/ModelAbstract.h
@@ -20,7 +20,10 @@
 
 #include "maths/BoundingBoxOriented.h"
 #include "graphics/RenderableObject.h"
+#include "graphics/Material.h"
+#include "ps/Game.h"
 #include "ps/Shapes.h"
+#include "renderer/Renderer.h"
 #include "simulation2/helpers/Player.h"
 
 class CModel;
@@ -60,15 +63,9 @@ public:
 
 public:
 	
-	CModelAbstract()
-		: m_Parent(NULL), m_PositionValid(false), m_ShadingColor(1, 1, 1, 1), m_PlayerID(INVALID_PLAYER), 
-		  m_SelectionBoxValid(false), m_CustomSelectionShape(NULL)
-	{ }
-
-	~CModelAbstract()
-	{
-		delete m_CustomSelectionShape; // allocated and set externally by CCmpVisualActor, but our responsibility to clean up
-	}
+	CModelAbstract();
+	
+	~CModelAbstract();
 
 	virtual CModelAbstract* Clone() const = 0;
 
@@ -149,16 +146,45 @@ public:
 	 */
 	virtual void InvalidatePosition() = 0;
 
-	virtual void SetPlayerID(player_id_t id) { m_PlayerID = id; }
+	virtual void SetPlayerID(player_id_t id);
+	
+		// set the model's material
+	virtual void SetMaterial(const CMaterial &material);
 
 	// get the model's player ID; initial default is INVALID_PLAYER
 	virtual player_id_t GetPlayerID() const { return m_PlayerID; }
+	int GetID() const { return m_ID; }
+	
+	// get the model's material
+	CMaterial& GetMaterial() { return m_Material; }
 
-	virtual void SetShadingColor(const CColor& color) { m_ShadingColor = color; }
+	virtual void SetShadingColor(const CColor& color);
 	virtual CColor GetShadingColor() const { return m_ShadingColor; }
 
 protected:
 	void CalcSelectionBox();
+	int AcquireID()
+	{
+		if (m_FreeIDs.empty())
+		{
+			for (int i=m_MaxID; i<m_MaxID+100; ++i)
+				m_FreeIDs.insert(i);
+			m_MaxID += 100;
+		}
+		int ret = *m_FreeIDs.begin();
+		m_FreeIDs.erase(m_FreeIDs.begin());
+		return ret;
+	}
+
+	void FreeID(int ID)
+	{
+		// The set could handle insertion of an ID which is alredy in the set, but
+		// this would still indicate a problem because it should not happen that an 
+		// already free ID gets freed again. 
+		ENSURE(m_FreeIDs.find(ID) == m_FreeIDs.end());
+
+		m_FreeIDs.insert(ID);
+	}
 
 public:
 	/// If non-null, points to the model that we are attached to.
@@ -168,7 +194,10 @@ public:
 	bool m_PositionValid;
 
 	player_id_t m_PlayerID;
-
+	
+	// model's material
+	CMaterial m_Material;
+	
 	/// Modulating color
 	CColor m_ShadingColor;
 
@@ -185,6 +214,10 @@ protected:
 	/// field will be used.
 	/// @see SetCustomSelectionShape
 	CustomSelectionShape* m_CustomSelectionShape;
+	
+	static std::set<int> m_FreeIDs;
+	static int m_MaxID;
+	int m_ID;
 
 };
 
diff --git a/source/graphics/MultiDrawIndirectCommands.h b/source/graphics/MultiDrawIndirectCommands.h
new file mode 100644
index 0000000..7983a33
--- /dev/null
+++ b/source/graphics/MultiDrawIndirectCommands.h
@@ -0,0 +1,116 @@
+/* Copyright (C) 2015 Wildfire Games.
+ * This file is part of 0 A.D.
+ *
+ * 0 A.D. is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * 0 A.D. is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with 0 A.D.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef INCLUDED_MULTIDRAWINDIRECTCOMMANDS
+#define INCLUDED_MULTIDRAWINDIRECTCOMMANDS
+
+#include <vector>
+
+#include "lib/ogl.h"
+
+#define MAX_INSTANCING_DRAWIDS	2000
+
+class MultiDrawIndirectCommands
+{
+public:
+	MultiDrawIndirectCommands() :
+		m_CurrentDrawID(0),
+		m_DrawCommands(MAX_INSTANCING_DRAWIDS)
+	 {
+	 	pglGenBuffersARB(1, &m_BufferID);
+	 }
+
+	struct DrawElementsIndirectCommand
+	{
+		GLuint  count;
+		GLuint  instanceCount;
+		GLuint  firstIndex;
+		GLuint  baseVertex;
+		GLuint  baseInstance;
+	};
+	
+	/**
+	 * Discard all commands in order to start creating new ones
+	 */
+	void ResetCommands()
+	{
+		m_DrawCommands.clear();
+		m_DrawCommands.reserve(MAX_INSTANCING_DRAWIDS);
+	}
+	
+	/**
+	 * We use the current 
+	 */
+	void ResetDrawID()
+	{
+		m_CurrentDrawID = 0;
+	}
+
+	void AddCommand(GLuint primCount, GLuint instanceCount, GLuint firstIndex, GLuint baseVertex)
+	{
+		m_DrawCommands.push_back(DrawElementsIndirectCommand { primCount, instanceCount, firstIndex, baseVertex, m_CurrentDrawID });
+		m_CurrentDrawID++;
+	}
+	
+	/**
+	 * Increments the instanceCount of the last command added
+	 */
+	void AddInstance()
+	{
+		m_DrawCommands.back().instanceCount++;
+		m_CurrentDrawID++;
+	}
+
+	void BindAndUpload()
+	{
+		pglBindBufferARB(GL_DRAW_INDIRECT_BUFFER, m_BufferID);
+		pglBufferDataARB(GL_DRAW_INDIRECT_BUFFER, m_DrawCommands.size() * sizeof(DrawElementsIndirectCommand), &m_DrawCommands[0], GL_STATIC_DRAW);
+		m_CurrentDrawID = 0;
+	}
+
+	size_t GetCommandCount()
+	{
+		return m_DrawCommands.size();
+	}
+	
+	void Draw(u32 modelsCount)
+	{
+			ENSURE(m_DrawCommands.size() >= modelsCount);
+			//pglDrawRangeElementsEXT(GL_TRIANGLES, 0, (GLuint)m->imodeldef->m_Array.GetNumVertices()-1,
+			//	(GLsizei)numFaces*3, GL_UNSIGNED_SHORT, m->imodeldefIndexBase);
+			ogl_WarnIfError();
+			pglMultiDrawElementsIndirect(GL_TRIANGLES,
+			GL_UNSIGNED_SHORT,
+  			(void*)(m_CurrentDrawID * sizeof(DrawElementsIndirectCommand)),
+  			modelsCount,
+  			sizeof(DrawElementsIndirectCommand));
+  			ogl_WarnIfError();
+  			m_CurrentDrawID += modelsCount;
+	}
+
+private:
+	std::vector<DrawElementsIndirectCommand> m_DrawCommands;
+	GLuint m_BufferID;
+	
+	// A drawID is used by the shaders to access instanced unforms.
+	// NOTE: This is independent of how many instances we can draw per
+	// command. It just depends on how many instanced uniforms are stored
+	// in uniform blocks, which is nothing we control inside this class.
+	GLuint m_CurrentDrawID;
+};
+
+#endif // INCLUDED_MULTIDRAWINDIRECTCOMMANDS
diff --git a/source/graphics/ObjectEntry.cpp b/source/graphics/ObjectEntry.cpp
index 4427a4f..cfb868b 100644
--- a/source/graphics/ObjectEntry.cpp
+++ b/source/graphics/ObjectEntry.cpp
@@ -127,7 +127,8 @@ bool CObjectEntry::BuildVariation(const std::vector<std::set<CStr> >& selections
 	delete m_Model;
 	m_Model = model;
 	model->SetMaterial(g_Renderer.GetMaterialManager().LoadMaterial(m_Base->m_Material));
-	model->GetMaterial().AddStaticUniform("objectColor", CVector4D(m_Color.r, m_Color.g, m_Color.b, m_Color.a));
+	//model->GetMaterial().AddStaticUniform("objectColor", CVector4D(m_Color.r, m_Color.g, m_Color.b, m_Color.a));
+	model->GetMaterial().AddStaticBlockUniform(CStrIntern("MaterialUBO"), CStrIntern("objectColor[0]"), true, CVector4D(m_Color.r, m_Color.g, m_Color.b, m_Color.a));
 	model->InitModel(modeldef);
 	
 	if (m_Samplers.empty())
diff --git a/source/graphics/ShaderBlockUniforms.cpp b/source/graphics/ShaderBlockUniforms.cpp
new file mode 100644
index 0000000..d7b166a
--- /dev/null
+++ b/source/graphics/ShaderBlockUniforms.cpp
@@ -0,0 +1,51 @@
+/* Copyright (C) 2012 Wildfire Games.
+ * This file is part of 0 A.D.
+ *
+ * 0 A.D. is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * 0 A.D. is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with 0 A.D.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "precompiled.h"
+
+#include "ShaderBlockUniforms.h"
+
+#include "graphics/UniformBlockManager.h"
+#include "graphics/ShaderProgram.h"
+#include "maths/Vector4D.h"
+#include "ps/ThreadUtil.h"
+#include "ps/Profile.h"
+
+#include <sstream>
+
+bool CShaderBlockUniforms::GetBindings()
+{
+	//m_BoundValueAssignments.clear();
+	UniformBlockManager& uniformBlockManager = g_Renderer.GetUniformBlockManager();
+	std::vector<BoundValueAssignment> tmpBoundAssignments;
+	tmpBoundAssignments.reserve(m_UnboundValueAssignments.size());
+	for (const UnboundValueAssignment& unboundAssignment : m_UnboundValueAssignments)
+	{
+		UniformBinding binding = uniformBlockManager.GetBinding(unboundAssignment.BlockName, unboundAssignment.UniformName, unboundAssignment.IsInstanced);
+		if (!binding.Active())
+			return false;
+		
+		tmpBoundAssignments.emplace_back(BoundValueAssignment { binding, unboundAssignment.Value });
+	}
+	
+	if (tmpBoundAssignments.size() == 0)
+		return false;
+	
+	m_BoundValueAssignments = tmpBoundAssignments;
+	m_UniformsBound = true;
+	return true;
+}
diff --git a/source/graphics/ShaderBlockUniforms.h b/source/graphics/ShaderBlockUniforms.h
new file mode 100644
index 0000000..fdcc8d0
--- /dev/null
+++ b/source/graphics/ShaderBlockUniforms.h
@@ -0,0 +1,74 @@
+/* Copyright (C) 2015 Wildfire Games.
+ * This file is part of 0 A.D.
+ *
+ * 0 A.D. is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * 0 A.D. is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with 0 A.D.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef INCLUDED_SHADERBLOCKUNIFORMS
+#define INCLUDED_SHADERBLOCKUNIFORMS
+
+#include "graphics/ShaderProgramPtr.h"
+#include "graphics/UniformBuffer.h"
+#include "ps/CStr.h"
+#include "ps/CStrIntern.h"
+#include "ps/CLogger.h"
+#include "renderer/Renderer.h"
+
+
+
+/**
+ * Represets value assignments to a number of uniforms from one or more blocks.
+ * 
+ * 1. Add your value assignments. Use names to identify uniform blocks and uniforms within these blocks.
+ * 2. Establish bindings. Validations if the block and uniform names exists happen here.
+ * 3. Now call SetUniforms to copy the values to the buffers using the established bindings.
+ */
+class CShaderBlockUniforms
+{
+public:
+	
+	CShaderBlockUniforms() :
+		m_UniformsBound(false)
+	{}
+	
+	struct UnboundValueAssignment
+	{
+		CStrIntern BlockName;
+		CStrIntern UniformName;
+		bool IsInstanced;
+		CVector4D Value;
+	};
+	
+	struct BoundValueAssignment
+	{
+		UniformBinding Binding;
+		CVector4D Value;
+	};
+	
+	void Add(CStrIntern blockName, CStrIntern uniformName, bool isInstanced, CVector4D value)
+	{
+		m_UnboundValueAssignments.emplace_back(UnboundValueAssignment { blockName, uniformName, isInstanced, value });
+	}
+	
+	bool GetBindings();
+
+	std::vector<BoundValueAssignment> m_BoundValueAssignments;
+	
+private:
+	
+	bool m_UniformsBound;
+	std::vector<UnboundValueAssignment> m_UnboundValueAssignments;
+};
+
+#endif // INCLUDED_SHADERBLOCKUNIFORMS
diff --git a/source/graphics/ShaderDefines.cpp b/source/graphics/ShaderDefines.cpp
index 57a65e5..4890225 100644
--- a/source/graphics/ShaderDefines.cpp
+++ b/source/graphics/ShaderDefines.cpp
@@ -22,6 +22,7 @@
 #include "graphics/ShaderProgram.h"
 #include "maths/Vector4D.h"
 #include "ps/ThreadUtil.h"
+#include "ps/Profile.h"
 
 #include <sstream>
 
@@ -232,7 +233,7 @@ void CShaderUniforms::BindUniforms(const CShaderProgramPtr& shader) const
 	const std::vector<SItems::Item>& items = m_Items->items;
 	for (size_t i = 0; i < items.size(); ++i)
 	{
-		CShaderProgram::Binding binding = shader->GetUniformBinding(items[i].first);
+		Binding binding = shader->GetUniformBinding(items[i].first);
 		if (binding.Active())
 		{
 			CVector4D v = items[i].second;
diff --git a/source/graphics/ShaderDefines.h b/source/graphics/ShaderDefines.h
index d635272..dd8e65b 100644
--- a/source/graphics/ShaderDefines.h
+++ b/source/graphics/ShaderDefines.h
@@ -19,11 +19,42 @@
 #define INCLUDED_SHADERDEFINES
 
 #include "graphics/ShaderProgramPtr.h"
+//#include "graphics/UniformBlockManager.h"
 #include "ps/CStr.h"
 #include "ps/CStrIntern.h"
+#include "ps/CLogger.h"
 
 #include <boost/unordered_map.hpp>
 
+/**
+ * Represents a uniform attribute or texture binding.
+ * For uniforms:
+ *  - ARB shaders store vertex location in 'first', fragment location in 'second'.
+ *  - GLSL shaders store uniform location in 'first', data type in 'second'.
+ *  - FFP shaders store -1 in 'first', index in 'second'.
+ * For textures, all store texture target (e.g. GL_TEXTURE_2D) in 'first', texture unit in 'second'.
+ * For uniform blocks:
+ *  - Bindings are managed by the uniform manager. An ID for the block is stored in 'first', 
+ *    an ID for the uniform within the block in 'second', data type in third.
+ * Non-existent bindings must store -1 in both.
+ */
+struct Binding
+{
+	Binding(int a, int b) : first(a), second(b), third(-1) { }
+	Binding(int a, int b, int c) : first(a), second(b), third(c) { }
+	Binding() : first(-1), second(-1), third(-1) { }
+
+	/**
+	 * Returns whether this uniform attribute is active in the shader.
+	 * If not then there's no point calling Uniform() to set its value.
+	 */
+	bool Active() { return first != -1 || second != -1 || third != -1; }
+
+	int first;
+	int second;
+	int third;
+};
+
 class CVector4D;
 
 /**
diff --git a/source/graphics/ShaderProgram.cpp b/source/graphics/ShaderProgram.cpp
index 5d7a135..da8d8bf 100644
--- a/source/graphics/ShaderProgram.cpp
+++ b/source/graphics/ShaderProgram.cpp
@@ -21,6 +21,8 @@
 
 #include "graphics/ShaderManager.h"
 #include "graphics/TextureManager.h"
+#include "graphics/UniformBlockManager.h"
+#include "graphics/UniformBuffer.h"
 #include "lib/res/graphics/ogl_tex.h"
 #include "maths/Matrix3D.h"
 #include "maths/Vector3D.h"
@@ -28,6 +30,7 @@
 #include "ps/Filesystem.h"
 #include "ps/PreprocessorWrapper.h"
 #include "ps/Shapes.h"
+#include "renderer/Renderer.h"
 
 #if !CONFIG2_GLES
 
@@ -408,6 +411,17 @@ public:
 				ogl_WarnIfError();
 			}
 		}
+		
+		int numSSBOBlocks = 0;
+		int numUBOBlocks = 0;
+		std::cout << "Linking Shader. m_Program = " << m_Program << std::endl;
+		std::cout << "VS: " << m_VertexFile.Filename().string8().c_str() << std::endl;
+		std::cout << "VS: " << m_FragmentFile.Filename().string8().c_str() << std::endl;
+		InterfaceBlock::GetBlockIdentifiers(m_Program, m_InterfaceBlockIdentifiers, numUBOBlocks, numSSBOBlocks);
+		UniformBlockManager& uniformBlockManager = g_Renderer.GetUniformBlockManager();
+		uniformBlockManager.RegisterUniformBlocks(*this);
+		m_UBOBindings.resize(numUBOBlocks);
+		m_SSBOBindings.resize(numSSBOBlocks);
 
 		// TODO: verify that we're not using more samplers than is supported
 
@@ -642,7 +656,7 @@ private:
 	CShaderDefines m_Defines;
 	std::map<CStrIntern, int> m_VertexAttribs;
 
-	GLhandleARB m_Program;
+	//GLhandleARB m_Program;
 	GLhandleARB m_VertexShader;
 	GLhandleARB m_FragmentShader;
 
diff --git a/source/graphics/ShaderProgram.h b/source/graphics/ShaderProgram.h
index 2440c76..6e1accd 100644
--- a/source/graphics/ShaderProgram.h
+++ b/source/graphics/ShaderProgram.h
@@ -19,10 +19,12 @@
 #define INCLUDED_SHADERPROGRAM
 
 #include "graphics/ShaderProgramPtr.h"
+#include "graphics/ShaderDefines.h"
 #include "graphics/Texture.h"
 #include "lib/ogl.h"
 #include "lib/file/vfs/vfs_path.h"
 #include "lib/res/handle.h"
+#include "graphics/UniformBinding.h"
 
 #include <map>
 
@@ -92,31 +94,6 @@ public:
 	 * Construct an instance of a pre-defined fixed-function pipeline setup.
 	 */
 	static CShaderProgram* ConstructFFP(const std::string& id, const CShaderDefines& defines);
-	
-	/**
-	 * Represents a uniform attribute or texture binding.
-	 * For uniforms:
-	 *  - ARB shaders store vertex location in 'first', fragment location in 'second'.
-	 *  - GLSL shaders store uniform location in 'first', data type in 'second'.
-	 *  - FFP shaders store -1 in 'first', index in 'second'.
-	 * For textures, all store texture target (e.g. GL_TEXTURE_2D) in 'first', texture unit in 'second'.
-	 * Non-existent bindings must store -1 in both.
-	 */
-	struct Binding
-	{
-		Binding(int a, int b) : first(a), second(b) { }
-
-		Binding() : first(-1), second(-1) { }
-
-		/**
-		 * Returns whether this uniform attribute is active in the shader.
-		 * If not then there's no point calling Uniform() to set its value.
-		 */
-		bool Active() { return first != -1 || second != -1; }
-
-		int first;
-		int second;
-	};
 
 	virtual ~CShaderProgram() { }
 
@@ -143,6 +120,11 @@ public:
 	 * vertex shader needs (e.g. position, color, UV, ...).
 	 */
 	int GetStreamFlags() const;
+	
+	GLuint GetProgram() const
+	{
+		return m_Program;
+	}
 
 
 	virtual Binding GetTextureBinding(texture_id_t id) = 0;
@@ -192,9 +174,63 @@ public:
 	 * Call this before calling glDrawArrays/glDrawElements etc to avoid potential crashes.
 	 */
 	void AssertPointersBound();
+	
+	void UniformBlockBinding(const InterfaceBlockIdentifier& uniformBlockIdentifier, GLuint bindingPoint)
+	{
+		ENSURE(uniformBlockIdentifier.BlockType == GL_UNIFORM_BLOCK || uniformBlockIdentifier.BlockType == GL_SHADER_STORAGE_BLOCK);
+		
+		if (uniformBlockIdentifier.BlockType == GL_UNIFORM_BLOCK)
+		{
+			pglUniformBlockBinding(m_Program, uniformBlockIdentifier.ID, bindingPoint);
+			m_UBOBindings[uniformBlockIdentifier.ID] = bindingPoint;
+		}
+		else if (uniformBlockIdentifier.BlockType == GL_SHADER_STORAGE_BLOCK)
+		{
+			std::cout << "pglShaderStorageBlockBinding: Name: " << uniformBlockIdentifier.Name.c_str() <<  " blockId:" << uniformBlockIdentifier.ID << " binding: " << bindingPoint << " Program: " << m_Program << std::endl;
+			pglShaderStorageBlockBinding(m_Program, uniformBlockIdentifier.ID, bindingPoint);
+			m_SSBOBindings[uniformBlockIdentifier.ID] = bindingPoint;
+		}
+	}
+	
+	GLuint GetUniformBlockBindingPoint(const int blockType, GLuint blockID)
+	{
+		ENSURE(blockType == GL_UNIFORM_BLOCK || blockType == GL_SHADER_STORAGE_BLOCK);
+		
+		if (blockType == GL_UNIFORM_BLOCK)
+		{
+			// TODO: replace with ENSURE?
+			if (blockID >= m_UBOBindings.size())
+			{
+				std::cerr << "Trying to query shader for non-existant uniform block index!" << std::endl;
+				return 0;
+			}
+			return m_UBOBindings[blockID];
+		}
+		else if (blockType == GL_SHADER_STORAGE_BLOCK)
+		{
+			// TODO: replace with ENSURE?
+			if (blockID >= m_SSBOBindings.size())
+			{
+				std::cerr << "Trying to query shader for non-existant shader storage block index!" << std::endl;
+				return 0;
+			}
+			return m_SSBOBindings[blockID];
+		}
+	}
+	
+	const std::vector<InterfaceBlockIdentifier>& GetUniformBlockIdentifiers() const
+	{
+		return m_InterfaceBlockIdentifiers;
+	}
 
 protected:
 	CShaderProgram(int streamflags);
+	
+	std::vector<GLuint> m_UBOBindings; // which block (by ID) is bound to which binding point
+	std::vector<GLuint> m_SSBOBindings;
+	std::vector<InterfaceBlockIdentifier> m_InterfaceBlockIdentifiers;
+	
+	GLuint m_Program;
 
 	bool m_IsValid;
 	int m_StreamFlags;
diff --git a/source/graphics/UniformBinding.h b/source/graphics/UniformBinding.h
new file mode 100644
index 0000000..583350a
--- /dev/null
+++ b/source/graphics/UniformBinding.h
@@ -0,0 +1,51 @@
+/* Copyright (C) 2015 Wildfire Games.
+ * This file is part of 0 A.D.
+ *
+ * 0 A.D. is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * 0 A.D. is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with 0 A.D.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef INCLUDED_UNIFORMBINDING
+#define INCLUDED_UNIFORMBINDING
+
+#include "lib/ogl.h"
+
+#include "ps/CStrIntern.h"
+
+struct UniformBinding
+{
+	UniformBinding(int blockType, int blockId, int uniformId, int type, bool isInstanced) : 
+		m_BlockType(blockType), m_BlockId(blockId), m_UniformId(uniformId), m_Type(type), m_IsInstanced(isInstanced) { }
+	UniformBinding() : m_BlockType(-1), m_BlockId(-1), m_UniformId(-1), m_Type(-1), m_IsInstanced(false) { }
+
+	bool Active() { return m_BlockType != -1 && m_BlockId != -1 && m_UniformId != -1; }
+
+	int m_BlockType; // GL_UNIFORM_BLOCK or GL_SHADER_STORAGE_BLOCK
+	int m_BlockId;
+	int m_UniformId;
+	int m_Type;
+	bool m_IsInstanced;
+};
+
+/**
+ * Identifies a uniform block by name and ID.
+ * The ID is only valid for one specific shader and might be different for other shaders 
+ */ 
+struct InterfaceBlockIdentifier
+{
+	int BlockType; // GL_UNIFORM_BLOCK or GL_SHADER_STORAGE_BLOCK
+	GLuint ID;
+	CStrIntern Name;
+};
+
+#endif // INCLUDED_UNIFORMBINDING
diff --git a/source/graphics/UniformBlockManager.cpp b/source/graphics/UniformBlockManager.cpp
new file mode 100644
index 0000000..d0a74d6
--- /dev/null
+++ b/source/graphics/UniformBlockManager.cpp
@@ -0,0 +1,159 @@
+/* Copyright (C) 2015 Wildfire Games.
+ * This file is part of 0 A.D.
+ *
+ * 0 A.D. is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * 0 A.D. is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with 0 A.D.  If not, see <http://www.gnu.org/licenses/>.
+ */
+ 
+#include "precompiled.h"
+
+#include "UniformBlockManager.h"
+#include "graphics/ShaderProgram.h"
+
+void UniformBlockManager::RegisterUniformBlocks(const CShaderProgram& shader)
+{
+	const std::vector<InterfaceBlockIdentifier>& blockIdentifiers = shader.GetUniformBlockIdentifiers();
+	
+	for (const InterfaceBlockIdentifier& blockIdentifier : blockIdentifiers)
+	{
+		const auto& nameIndexLookup = m_InterfaceBlockIndices.find(blockIdentifier.Name);
+		if (nameIndexLookup != m_InterfaceBlockIndices.end())
+			continue; // block already added
+		
+		// No such uniform block available so far, create one from the current shader program
+		m_InterfaceBlockBuffers.emplace_back(shader.GetProgram(), blockIdentifier, blockIdentifier.BlockType);
+		m_DirtyBuffers.resize(m_InterfaceBlockBuffers.size());
+		m_InterfaceBlockIndices.emplace(blockIdentifier.Name, m_InterfaceBlockBuffers.size() - 1);
+		InterfaceBlockAdded(blockIdentifier);
+	}
+}
+
+void UniformBlockManager::MaterialBound(const int materialID, CShaderBlockUniforms& shaderBlockUniforms)
+{
+	std::cout << "MaterialBound: " << materialID << std::endl;
+	for (CShaderBlockUniforms::BoundValueAssignment& boundValue : 
+		shaderBlockUniforms.m_BoundValueAssignments)
+	{
+		SetCurrentInstance<MATERIAL_INSTANCED>(materialID);
+		SetUniformF4<MATERIAL_INSTANCED>(boundValue.Binding, boundValue.Value.X, 
+			boundValue.Value.Y, boundValue.Value.Z, boundValue.Value.W);
+	}
+}
+
+void UniformBlockManager::InterfaceBlockAdded(const InterfaceBlockIdentifier& blockIdentifier)
+{
+	std::cout << "InterfaceBlock added: " << blockIdentifier.Name.c_str() << std::endl;
+	UpdateMaterialBinding();
+	
+	int flags = 0;
+	if (blockIdentifier.Name == m_PlayerColorBlockName)
+	{
+		flags |= PLAYER_COLOR;
+		m_PlayerColorBinding = GetBinding(m_PlayerColorBlockName, str_playerColor_0, true);
+	}
+	else if (blockIdentifier.Name == m_ShadingColorBlockName)
+	{
+		flags |= SHADING_COLOR;
+		m_ShadingColorBinding = GetBinding(m_ShadingColorBlockName, str_shadingColor_0, true);
+	}
+	else if (blockIdentifier.Name == m_MaterialIDBlockName)
+	{
+		flags |= MATERIAL_ID;
+		m_MaterialIDBinding = GetBinding(m_MaterialIDBlockName, CStrIntern("materialID[0]"), true);
+	}
+	
+	if(!flags)
+		return;
+	
+	m_AvailableBindingsFlag |= flags;
+	GenAllModelData(flags);
+}
+
+
+bool UniformBlockManager::EnsureBlockBinding(const CShaderProgramPtr& shader)
+{
+
+	// TODO: Check if there are enough free binding points
+	
+	const std::vector<InterfaceBlockIdentifier>& blockIdentifiers = shader->GetUniformBlockIdentifiers();
+
+	for (const InterfaceBlockIdentifier& blockIdentifier : blockIdentifiers)
+	{
+		std::map<CStrIntern, PointBufferBinding>::iterator pointBinding;
+		std::map<CStrIntern, PointBufferBinding>::iterator endItr;
+		
+		// TODO: Maybe another define could be use that starts with 0 and then that could be
+		// used as index like this in an array of maps:
+		//
+		// Declaration:
+		// enum PS_INTERFACE_BLOCK_TYPES { PS_UNIFORM_BLOCK, PS_SHADER_STORAGE_BLOCK };
+		// std::map<CStrIntern, PointBufferBinding> m_PointBindings[2];
+		//
+		// Use:
+		// m_PointBindings[PS_UNIFORM_BLOCK].find(blockIdentifier.Name);
+		//
+		// This should make the code a bit cleaner and remove some branching
+
+		
+		if (blockIdentifier.BlockType == GL_UNIFORM_BLOCK)
+		{
+			pointBinding = m_UBOPointBindings.find(blockIdentifier.Name);
+			endItr = m_UBOPointBindings.end();
+		}
+		else if (blockIdentifier.BlockType == GL_SHADER_STORAGE_BLOCK)
+		{
+			pointBinding = m_SSBOPointBindings.find(blockIdentifier.Name);
+			endItr = m_SSBOPointBindings.end();
+		}
+		
+		if (pointBinding != endItr)
+		{
+			// check if the block in the shader is bound to the same point where the buffer is mapped
+			if (shader->GetUniformBlockBindingPoint(blockIdentifier.BlockType, blockIdentifier.ID) == pointBinding->second.point)
+				continue; // this block is correctly bound
+			else // the binding point is mapped to the buffer, but the shader points to the wrong binding point
+			{
+				shader->UniformBlockBinding(blockIdentifier, pointBinding->second.point);
+				//glUniformBlockBinding(shader, shader.GetBlockID(blockIdentifier.Name), pointBinding.second.point);
+			}
+		}
+		else	// currently there's no buffer for this block attached to any points
+		{
+			const auto& nameIndexLookup  = m_InterfaceBlockIndices.find(blockIdentifier.Name);
+			if (nameIndexLookup == m_InterfaceBlockIndices.end())
+			{
+				// All blocks of this shader should have been registered using RegisterUniformBlocks.
+				// This code path should never be reached, unless there's a code issue
+				// TODO: replace with debug_warn or ENSURE?
+				std::cerr << "Trying to bind a uniform block which hasn't been loaded yet by the UniformBlockManager!";
+				return false;
+			}
+
+			if (blockIdentifier.BlockType == GL_UNIFORM_BLOCK)
+			{
+				pglBindBufferBase(GL_UNIFORM_BUFFER, m_NextFreeUBOBindingPoint, m_InterfaceBlockBuffers[nameIndexLookup->second].m_UBOBufferID);
+				m_UBOPointBindings.emplace(blockIdentifier.Name, PointBufferBinding { m_NextFreeUBOBindingPoint });
+				shader->UniformBlockBinding(blockIdentifier, m_NextFreeUBOBindingPoint);
+				m_NextFreeUBOBindingPoint++;
+			} 
+			else if (blockIdentifier.BlockType == GL_SHADER_STORAGE_BLOCK)
+			{
+				std::cout << "pglBindBufferBase: BindingPoint: " << m_NextFreeSSBOBindingPoint << " BufferName: " << m_InterfaceBlockBuffers[nameIndexLookup->second].m_BlockName.c_str() << " BufferID: " << m_InterfaceBlockBuffers[nameIndexLookup->second].m_UBOBufferID << std::endl;
+				pglBindBufferBase(GL_SHADER_STORAGE_BUFFER, m_NextFreeSSBOBindingPoint, m_InterfaceBlockBuffers[nameIndexLookup->second].m_UBOBufferID);
+				m_SSBOPointBindings.emplace(blockIdentifier.Name, PointBufferBinding { m_NextFreeSSBOBindingPoint });
+				shader->UniformBlockBinding(blockIdentifier, m_NextFreeSSBOBindingPoint);
+				m_NextFreeSSBOBindingPoint++;
+			}
+		}
+	}
+}
\ No newline at end of file
diff --git a/source/graphics/UniformBlockManager.h b/source/graphics/UniformBlockManager.h
new file mode 100644
index 0000000..65850ba
--- /dev/null
+++ b/source/graphics/UniformBlockManager.h
@@ -0,0 +1,423 @@
+/* Copyright (C) 2015 Wildfire Games.
+ * This file is part of 0 A.D.
+ *
+ * 0 A.D. is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * 0 A.D. is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with 0 A.D.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef INCLUDED_UNIFORMBINDINGMANAGER
+#define INCLUDED_UNIFORMBINDINGMANAGER
+
+#include <map>
+
+#include "graphics/ModelAbstract.h"
+#include "graphics/UniformBinding.h"
+#include "graphics/UniformBuffer.h"
+#include "graphics/ShaderProgramPtr.h"
+#include "graphics/ShaderBlockUniforms.h"
+
+
+/**
+ * Knows about available binding points. Gets informed whenever changing of bindings might be required and 
+ * manages the binding to avoid unnecessary rebinding.
+ *
+ * Basically I'm trying to prepare data for as many draw calls as possible (trying to minimize reuse of binding points for different blocks)
+ * It should be possible to reuse some bindings instead of just setting them up again after ResetBindings is called. I'm currently not trying
+ * to do this because it would add more overhead and complexity and because I don't know if it would be worth it.
+ *
+ */
+class UniformBlockManager
+{
+public:
+	UniformBlockManager() :
+		m_NextFreeUBOBindingPoint(1),
+		m_NextFreeSSBOBindingPoint(1),
+		m_MaxUBOBindings(0),
+		m_MaxSSBOBindings(0),
+		m_CurrentInstance(0),
+		m_AvailableBindingsFlag(0),
+		m_PlayerColorBlockName("PlayerColorBlock"),
+		m_ShadingColorBlockName("ShadingColorBlock"),
+		m_MaterialIDBlockName("MaterialIDBlock")
+	{
+	}
+	
+	void Initialize()
+	{
+		glGetIntegerv(GL_MAX_UNIFORM_BUFFER_BINDINGS, &m_MaxUBOBindings);
+	}
+/*
+	void ResetBindings()
+	{ 
+		m_PointBindings.clear();
+		m_NextFreeUBOBindingPoint = 0;
+		m_NextFreeSSBOBindingPoint = 0;
+	}
+*/
+	
+	void RegisterUniformBlocks(const CShaderProgram& shader);
+
+	/**
+	 * @return: returns false if no more free binding points are available.
+	 * In this case you have to use the bindings that have been set up so far (draw)
+	 * and then call ResetBindings, which will allow the UniformBindingManager to
+	 * reuse the binding points again and possibly map them to different buffers.
+	 */  
+	bool EnsureBlockBinding(const CShaderProgramPtr& shader);
+	
+	enum InstancingMode { MODEL_INSTANCED, MATERIAL_INSTANCED, NOT_INSTANCED };
+	
+	template<InstancingMode M, typename T>
+	void SetUniform(UniformBinding id, T v)
+	{
+		// TODO: Is this actually required to trigger a compiler error in case of invalid enums?
+		static_assert(M == MODEL_INSTANCED || M == MATERIAL_INSTANCED || M == NOT_INSTANCED, 
+						"template parameter M must be either MODEL_INSTANCED or MATERIAL_INSTANCED!");
+		
+		ENSURE(m_DirtyBuffers.size() > id.m_BlockId);
+		ENSURE(m_InterfaceBlockBuffers.size() == m_DirtyBuffers.size());
+		
+		GLuint instanceId(0);
+		
+		if (id.m_IsInstanced)
+		{
+			if (M == MODEL_INSTANCED)
+				instanceId = m_CurrentInstance;
+			else if (M == MATERIAL_INSTANCED)
+				instanceId = m_CurrentMaterial;
+		}
+		
+		m_DirtyBuffers[id.m_BlockId] = true;
+		m_InterfaceBlockBuffers[id.m_BlockId].SetUniform(id, v, instanceId);
+	}
+	
+	template<typename T>
+	void SetUniform(UniformBinding id, GLuint instanceId, T v)
+	{		
+		ENSURE(m_DirtyBuffers.size() > id.m_BlockId);
+		ENSURE(m_InterfaceBlockBuffers.size() == m_DirtyBuffers.size());
+		
+		m_DirtyBuffers[id.m_BlockId] = true;
+		m_InterfaceBlockBuffers[id.m_BlockId].SetUniform(id, v, instanceId);
+	}
+	
+	/**
+	 * Sets an instanced array of T (array of array of T).
+	 */
+	template<InstancingMode M, typename T> 
+	void SetUniform(const UniformBinding& id, size_t count, const T* v)
+	{
+		// TODO: Is this actually required to trigger a compiler error in case of invalid enums?
+		static_assert(M == MODEL_INSTANCED || M == MATERIAL_INSTANCED || M == NOT_INSTANCED, 
+						"template parameter M must be either MODEL_INSTANCED or MATERIAL_INSTANCED!");
+		
+		ENSURE(m_DirtyBuffers.size() > id.m_BlockId);
+		ENSURE(m_InterfaceBlockBuffers.size() == m_DirtyBuffers.size());
+		
+		GLuint instanceId(0);
+		
+		if (id.m_IsInstanced)
+		{
+			if (M == MODEL_INSTANCED)
+				instanceId = m_CurrentInstance;
+			else if (M == MATERIAL_INSTANCED)
+				instanceId = m_CurrentMaterial;
+		}
+
+		m_DirtyBuffers[id.m_BlockId] = true;
+		m_InterfaceBlockBuffers[id.m_BlockId].SetUniform(id, count, v, instanceId);
+	}
+	
+	template <InstancingMode M>
+	void SetUniformF4(UniformBinding id, float v0, float v1, float v2, float v3)
+	{
+		// TODO: Is this actually required to trigger a compiler error in case of invalid enums?
+		static_assert(M == MODEL_INSTANCED || M == MATERIAL_INSTANCED || M == NOT_INSTANCED, 
+						"template parameter M must be either MODEL_INSTANCED or MATERIAL_INSTANCED!");
+		
+		ENSURE(m_DirtyBuffers.size() > id.m_BlockId);
+		ENSURE(m_InterfaceBlockBuffers.size() == m_DirtyBuffers.size());
+		
+		GLuint instanceId(0);
+		
+		if (id.m_IsInstanced)
+		{
+			if (M == MODEL_INSTANCED)
+				instanceId = m_CurrentInstance;
+			else if (M == MATERIAL_INSTANCED)
+				instanceId = m_CurrentMaterial;
+		}
+
+		m_DirtyBuffers[id.m_BlockId] = true;
+		m_InterfaceBlockBuffers[id.m_BlockId].SetUniformF4(id, v0, v1, v2, v3, instanceId);
+	}
+	
+	/**
+	 * Uploads all dirty blocks to the GPU.
+	 */
+	void Upload()
+	{
+		for (int i=0; i<m_DirtyBuffers.size(); ++i)
+		{
+			if (!m_DirtyBuffers[i])
+				continue;
+			
+			m_InterfaceBlockBuffers[i].Upload();
+			//std::cout << "Uploading InterfaceBlock: " << m_InterfaceBlockBuffers[i].m_BlockName.c_str() << std::endl;
+			m_DirtyBuffers[i] = false;
+		}
+		/*
+		for (int i=0; i<m_UniformBuffers.size(); ++i)
+			m_UniformBuffers[i].Upload();*/
+	}
+	
+	
+	/**
+	 * Get a binding for the specified uniform in the specified block
+	 *
+	 * Lookups by name are more expensive than direct access to indices.
+	 * Bindings store these indices and are used by SetUniform.
+	 * 
+	 * @return Returns a binding for the specified uniform in the specified block or 
+	 * an inactive binding if the block does not exist or the uniform does not exist
+	 * within that block. 
+	 */
+	UniformBinding GetBinding(CStrIntern blockName, CStrIntern uniformName, bool isInstanced) const
+	{
+		UniformBinding binding;
+		binding.m_IsInstanced = isInstanced;
+		const auto& blockLookup  = m_InterfaceBlockIndices.find(blockName);
+		if (blockLookup != m_InterfaceBlockIndices.end())
+		{
+			m_InterfaceBlockBuffers[blockLookup->second].GetBinding(binding, uniformName);
+			if (binding.m_UniformId != -1)
+				binding.m_BlockId = blockLookup->second; // the index of the buffer in m_UniformBuffers
+			return binding;
+		}	
+		
+		std::cerr << "GetBinding: not found block name: " << blockName.c_str() << std::endl;
+		return binding;
+	}
+	
+	template <InstancingMode M>
+	inline void SetCurrentInstance(GLuint instance);
+	
+	/*
+	GLuint GetCurrentInstance() { return m_CurrentMaterial; }
+	void SetCurrentInstance(GLuint instance) { m_CurrentMaterial = instance; }
+	
+	GLuint GetCurrentMaterial() { return m_CurrentMaterial; }
+	void SetCurrentMaterial(GLuint instance) { m_CurrentMaterial = instance; }
+	*/
+
+private:	
+
+	GLuint m_NextFreeUBOBindingPoint;
+	GLuint m_NextFreeSSBOBindingPoint;
+	
+	GLint m_MaxUBOBindings;
+	GLint m_MaxSSBOBindings;
+	
+	// The UniformBuffer class queries these for instanced data
+	GLuint m_CurrentInstance;
+	GLuint m_CurrentMaterial;
+
+	struct PointBufferBinding
+	{
+		GLuint point;
+	};
+	
+	// which buffer (by uniform block name) is bound to which binding point
+	//
+	// TODO: Could the concept of bindings be applied here too?
+	// Do one runtime call to get the binding ID from a block name, which is then
+	// used to access a vector. Vector access by index causes less overhead than map
+	// lookups.
+	std::vector<InterfaceBlock> m_InterfaceBlockBuffers;
+	std::map<CStrIntern, unsigned int> m_InterfaceBlockIndices; // used for easy lookup
+	
+	// TODO: Use index into m_UniformBuffers as key?
+	std::map<CStrIntern, PointBufferBinding> m_UBOPointBindings;
+	std::map<CStrIntern, PointBufferBinding> m_SSBOPointBindings;
+	//std::map<std::string, UniformBuffer> m_UniformBuffers;
+	
+	std::vector<bool> m_DirtyBuffers;
+	
+	
+	
+/**
+ * Keeps model data updated.
+ * It's not quite a trivial task to keep model data update in all the situations that might change
+ * certain parts of it. Also we can't get any bindings to uniforms or shader storage blocks before
+ * all shaders are loaded (and reloading might happen later).
+ *   
+ * We keep track of all Models in order to generate the data for all models as soon as the shaders
+ * were loaded. We also might want to recreate data again later when hotloading shaders or 
+ * changing rendering settings for example.
+ * We also listen to different event that might trigger changes to model data and update the data
+ * if needed.
+ */
+public:
+
+// Events that might trigger changes to model data
+	void ModelAdded(CModelAbstract* model)
+	{
+		ENSURE(m_Models.find(model) == m_Models.end());
+		m_Models.insert(model);
+		GenModelData(model, m_AvailableBindingsFlag);
+	}
+	void ModelRemoved(CModelAbstract* model)
+	{
+		ENSURE(m_Models.find(model) != m_Models.end());
+
+		m_Models.erase(model);
+	}
+
+	void MaterialAdded(CShaderBlockUniforms& shaderBlockUniforms, int MaterialID)
+	{
+		m_UnboundStaticBlockUniforms.insert({ MaterialID, shaderBlockUniforms});
+		//m_UnboundMaterials.insert(material);
+		UpdateMaterialBinding();
+	}
+	
+	void MaterialModified(CShaderBlockUniforms& shaderBlockUniforms, int MaterialID)
+	{
+		auto itr = m_UnboundStaticBlockUniforms.find(MaterialID);
+		if (itr != m_UnboundStaticBlockUniforms.end())
+		{
+			itr->second = shaderBlockUniforms;
+			return;
+		}
+			
+		m_UnboundStaticBlockUniforms.insert({ MaterialID, shaderBlockUniforms});
+		//m_UnboundMaterials.insert(material);
+		UpdateMaterialBinding();
+	}
+
+	void PlayerIDChanged(CModelAbstract* model)
+	{
+		if (m_PlayerColorBinding.Active())
+			SetPlayerColor(model);
+	}
+	
+	void ShadingColorChanged(CModelAbstract* model)
+	{
+		if (m_ShadingColorBinding.Active())
+			SetShadingColor(model);
+	}
+	
+	void MaterialChanged(CModelAbstract* model)
+	{
+		if (m_MaterialIDBinding.Active())
+			SetMaterialID(model);
+	}
+	// void PlayerIDColorChanged(...); // a color of a player probably can't change in-game
+
+private:
+	
+	struct PairIDBlockUniform
+	{
+		int m_MaterialID;
+		CShaderBlockUniforms m_BlockUniforms;
+	};
+
+	/// Events that might trigger changes to model data
+	
+	void InterfaceBlockAdded(const InterfaceBlockIdentifier& blockIdentifier);
+	
+	void MaterialBound(const int materialID, CShaderBlockUniforms& shaderBlockUniforms);
+	
+	/// Functions
+	
+	void SetPlayerColor(const CModelAbstract* model)
+	{
+		SetUniform(m_PlayerColorBinding, model->GetID(), g_Game->GetPlayerColor(model->GetPlayerID()));
+	}
+	
+	void SetShadingColor(const CModelAbstract* model)
+	{
+		SetUniform(m_ShadingColorBinding, model->GetID(), model->GetShadingColor());
+	}
+	
+	void SetMaterialID(CModelAbstract* model)
+	{
+		//std::cout << "Setting MaterialID: " << model->GetMaterial().GetId() << " for model: " << model->GetID() << std::endl;
+		ENSURE(model->GetID() < 20000); // TODO: Remove this hack
+		SetUniform(m_MaterialIDBinding, (GLuint)model->GetID(), (GLuint)model->GetMaterial().GetId());
+
+	}
+
+	void GenModelData(CModelAbstract* model, const int flags)
+	{
+		if (flags & PLAYER_COLOR)
+			SetPlayerColor(model);
+		if (flags & SHADING_COLOR)
+			SetShadingColor(model);
+		if (flags & MATERIAL_ID)
+			SetMaterialID(model);
+	}
+
+	void GenAllModelData(const int flags)
+	{
+		for (auto* model : m_Models)
+			GenModelData(model, flags);
+	}
+	
+	void UpdateMaterialBinding()
+	{
+		for (std::map<int, CShaderBlockUniforms>::iterator itr = m_UnboundStaticBlockUniforms.begin(); 
+			itr != m_UnboundStaticBlockUniforms.end();)
+		{
+			if (!itr->second.GetBindings())
+			{
+				++itr;
+				continue;
+			}
+			
+			MaterialBound(itr->first, itr->second);
+			itr = m_UnboundStaticBlockUniforms.erase(itr);
+		}
+	}
+	
+	/// data members
+	enum DATA_FLAGS { PLAYER_COLOR = 1, SHADING_COLOR = 2, MATERIAL_ID = 4 };
+	int m_AvailableBindingsFlag;
+	std::set<CModelAbstract*> m_Models;
+
+	// TODO: Add this to where the other static CStrIntern are defined
+	const CStrIntern m_PlayerColorBlockName;
+	const CStrIntern m_ShadingColorBlockName;
+	const CStrIntern m_MaterialIDBlockName;
+	UniformBinding m_PlayerColorBinding;
+	UniformBinding m_ShadingColorBinding;
+	UniformBinding m_MaterialIDBinding;
+	
+	//std::list<PairIDBlockUniform> m_UnboundStaticBlockUniforms;
+	std::map<int, CShaderBlockUniforms> m_UnboundStaticBlockUniforms;
+	//std::set<CMaterial*> m_UnboundMaterials;
+	//std::set<CMaterial*> m_BoundMaterials;
+};
+
+template<>
+inline void UniformBlockManager::SetCurrentInstance<UniformBlockManager::MODEL_INSTANCED>(GLuint instance)
+{
+	m_CurrentInstance = instance;
+}
+
+template<>
+inline void UniformBlockManager::SetCurrentInstance<UniformBlockManager::MATERIAL_INSTANCED>(GLuint instance)
+{
+	m_CurrentMaterial= instance;
+}
+
+#endif // INCLUDED_UNIFORMBINDINGMANAGER
diff --git a/source/graphics/UniformBuffer.cpp b/source/graphics/UniformBuffer.cpp
new file mode 100644
index 0000000..252aa90
--- /dev/null
+++ b/source/graphics/UniformBuffer.cpp
@@ -0,0 +1,350 @@
+/* Copyright (C) 2015 Wildfire Games.
+ * This file is part of 0 A.D.
+ *
+ * 0 A.D. is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * 0 A.D. is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with 0 A.D.  If not, see <http://www.gnu.org/licenses/>.
+ */
+ 
+#include "precompiled.h"
+ 
+#include "UniformBuffer.h"
+
+#include "ShaderProgram.h"
+#include "ShaderProgramPtr.h"
+
+#include "ps/Profile.h"
+
+#include <fstream>
+
+constexpr GLenum InterfaceBlock::MemberProps[];
+
+InterfaceBlock::InterfaceBlock(GLuint program, const InterfaceBlockIdentifier& blockIdentifier, const int interfaceBlockType) :
+	m_UBOSourceBuffer(),
+	m_BlockName(blockIdentifier.Name),
+	m_UBODirtyBytes(0),
+	m_InterfaceBlockType(interfaceBlockType),
+	m_BufferResized(false)
+{
+	if (interfaceBlockType == GL_UNIFORM_BLOCK)
+	{
+		m_MemberBufferType = GL_UNIFORM_BUFFER;
+		m_MemberType = GL_UNIFORM;
+	}
+	else if (interfaceBlockType == GL_SHADER_STORAGE_BLOCK)
+	{
+		m_MemberBufferType = GL_SHADER_STORAGE_BUFFER;
+		m_MemberType = GL_BUFFER_VARIABLE;
+	}
+	
+	
+	const GLenum blockProperties[1] = { GL_NUM_ACTIVE_VARIABLES };
+	const GLenum activeUnifProp[1] = { GL_ACTIVE_VARIABLES };
+	const int numTempMembers = 2;
+	const GLenum tmpMemberProps[numTempMembers] { GL_NAME_LENGTH, GL_TYPE };
+	GLint numActiveUnifs = 0;
+	
+	pglGetProgramResourceiv(program, interfaceBlockType, blockIdentifier.ID, 1, blockProperties, 1, NULL, &numActiveUnifs);
+
+	if(!numActiveUnifs)
+		return; // TODO: error handling
+		
+	m_UniformIndices.resize(numActiveUnifs);
+	pglGetProgramResourceiv(program, interfaceBlockType, blockIdentifier.ID, 1, activeUnifProp, numActiveUnifs, NULL, (GLint*)&m_UniformIndices[0]);
+	
+	m_MemberProps.resize(numActiveUnifs * PROPS::COUNT);
+	std::vector<GLint> tmpMemberValues(numTempMembers);
+	for(int unifIx = 0; unifIx < numActiveUnifs; ++unifIx)
+	{
+		pglGetProgramResourceiv(program, m_MemberType,
+			m_UniformIndices[unifIx], PROPS::COUNT,
+			MemberProps, PROPS::COUNT,
+			NULL, &m_MemberProps[unifIx * PROPS::COUNT]);
+		
+		pglGetProgramResourceiv(program, m_MemberType,
+			m_UniformIndices[unifIx], numTempMembers,
+			tmpMemberProps, numTempMembers,
+			NULL, &tmpMemberValues[0]);
+			
+		m_UniformTypes.emplace_back(tmpMemberValues[1]);
+		
+		std::vector<char> nameData(tmpMemberValues[0]);
+		pglGetProgramResourceName(program, m_MemberType, m_UniformIndices[unifIx], nameData.size(), NULL, &nameData[0]);
+		
+		// uniform names have the form blockName.uniformName, but we just want the uniformName part
+		auto it = std::find(nameData.begin(), nameData.end(), '.');
+		if (it == nameData.end())
+			it = nameData.begin();
+		else
+			it++; // one char after the dot
+		
+		m_UniformNames.emplace_back(std::string(it, nameData.end() - 1));
+	}
+		
+	const GLenum bufferDataSizeProperty[1] = { GL_BUFFER_DATA_SIZE };
+	pglGetProgramResourceiv(program, interfaceBlockType, blockIdentifier.ID, 1, bufferDataSizeProperty, 1, NULL, &m_UBOBlockSize);
+	m_UBOSourceBuffer.resize(m_UBOBlockSize);
+#if 1
+	memset(m_UBOSourceBuffer.data(), 0xFD, m_UBOBlockSize);
+#endif // DEBUG_UNIFORM_BUFFER
+	pglGenBuffersARB(1, &m_UBOBufferID);
+	pglBindBufferARB(m_MemberBufferType, m_UBOBufferID);
+	pglBufferDataARB(m_MemberBufferType, m_UBOBlockSize, NULL, GL_DYNAMIC_DRAW);
+	std::cout << "GenBuffer - Name: " << m_BlockName.c_str() << " ID: " << m_UBOBufferID << " size: " << m_UBOBlockSize << std::endl;
+}
+
+void InterfaceBlock::GetBlockIdentifiers(GLuint program, std::vector<InterfaceBlockIdentifier>& out, 
+	int& numUBOBlocks, int& numSSBOBlocks)
+{
+	GLint numBlocks;
+	GLint maxNameLength;
+	int blockTypes[] = { GL_UNIFORM_BLOCK, GL_SHADER_STORAGE_BLOCK };
+	
+	for (int blockType : blockTypes)
+	{	
+		pglGetProgramInterfaceiv(program, blockType, GL_ACTIVE_RESOURCES, &numBlocks);
+		pglGetProgramInterfaceiv(program, blockType, GL_MAX_NAME_LENGTH, &maxNameLength);
+		
+		if (blockType == GL_UNIFORM_BLOCK)
+			numUBOBlocks = numBlocks;
+		else if (blockType == GL_SHADER_STORAGE_BLOCK)
+			numSSBOBlocks = numBlocks;
+		
+		std::vector<char> nameData(maxNameLength);
+		for(GLuint blockId = 0; blockId < numBlocks; ++blockId)
+		{
+			pglGetProgramResourceName(program, blockType, blockId, nameData.size(), NULL, &nameData[0]);
+			out.push_back(InterfaceBlockIdentifier { blockType, blockId, CStrIntern(&nameData[0]) });
+			GLuint block_index = 0;
+    		block_index = pglGetProgramResourceIndex(program, blockType, out.back().Name.c_str());
+    		ENSURE(blockId == block_index);
+		}
+	}
+}
+
+
+// TODO: There's a lot of duplicated code here.
+// Maybe the old approach of just passing 4 floats would be better
+void InterfaceBlock::SetUniform(const UniformBinding& id, CVector4D v, GLuint instanceId)
+{
+	GLuint offset = GetMemberProp(id.m_UniformId, PROPS::PROP_OFFSET) + GetMemberProp(id.m_UniformId, PROPS::PROP_ARRAY_STRIDE) * instanceId;
+
+	m_UBODirtyBytes = std::max((size_t)m_UBODirtyBytes, (size_t)(offset + 4 * sizeof(float)));
+	
+	if (m_UBOBlockSize < m_UBODirtyBytes)
+		IncreaseBufferSize(m_UBODirtyBytes);
+		
+
+#if DEBUG_UNIFORM_BUFFER
+	for (int k = 0; k < sizeof(float); ++k)
+	{
+		ENSURE(*(m_UBOSourceBuffer.data() + offset + 0 * sizeof(float) + k) == 0xFD);
+		ENSURE(*(m_UBOSourceBuffer.data() + offset + 1 * sizeof(float) + k) == 0xFD);
+		ENSURE(*(m_UBOSourceBuffer.data() + offset + 2 * sizeof(float) + k) == 0xFD);
+		ENSURE(*(m_UBOSourceBuffer.data() + offset + 3 * sizeof(float) + k) == 0xFD);
+	}
+#endif // DEBUG_UNIFORM_BUFFER
+	*((float*)(m_UBOSourceBuffer.data() + offset + 0 * sizeof(float))) = v.X;
+	*((float*)(m_UBOSourceBuffer.data() + offset + 1 * sizeof(float))) = v.Y;
+	*((float*)(m_UBOSourceBuffer.data() + offset + 2 * sizeof(float))) = v.Z;
+	*((float*)(m_UBOSourceBuffer.data() + offset + 3 * sizeof(float))) = v.W;
+}
+
+void InterfaceBlock::SetUniform(const UniformBinding& id, CVector3D v, GLuint instanceId)
+{
+	GLuint offset = GetMemberProp(id.m_UniformId, PROPS::PROP_OFFSET) + GetMemberProp(id.m_UniformId, PROPS::PROP_ARRAY_STRIDE) * instanceId;
+	m_UBODirtyBytes = std::max((size_t)m_UBODirtyBytes, (size_t)(offset + 3 * sizeof(float)));
+
+	if (m_UBOBlockSize < m_UBODirtyBytes)
+		IncreaseBufferSize(m_UBODirtyBytes);
+#if DEBUG_UNIFORM_BUFFER
+	for (int k = 0; k < sizeof(float); ++k)
+	{
+		ENSURE(*(m_UBOSourceBuffer.data() + offset + 0 * sizeof(float) + k) == 0xFD);
+		ENSURE(*(m_UBOSourceBuffer.data() + offset + 1 * sizeof(float) + k) == 0xFD);
+		ENSURE(*(m_UBOSourceBuffer.data() + offset + 2 * sizeof(float) + k) == 0xFD);
+	}
+#endif // DEBUG_UNIFORM_BUFFER
+	*((float*)(m_UBOSourceBuffer.data() + offset + 0 * sizeof(float))) = v.X;
+	*((float*)(m_UBOSourceBuffer.data() + offset + 1 * sizeof(float))) = v.Y;
+	*((float*)(m_UBOSourceBuffer.data() + offset + 2 * sizeof(float))) = v.Z;
+}
+
+void InterfaceBlock::SetUniform(const UniformBinding& id, CVector2D v, GLuint instanceId)
+{
+	GLuint offset = GetMemberProp(id.m_UniformId, PROPS::PROP_OFFSET) + GetMemberProp(id.m_UniformId, PROPS::PROP_ARRAY_STRIDE) * instanceId;
+	m_UBODirtyBytes = std::max((size_t)m_UBODirtyBytes, (size_t)(offset + 2 * sizeof(float)));
+	if (m_UBOBlockSize < m_UBODirtyBytes)
+		IncreaseBufferSize(m_UBODirtyBytes);
+#if DEBUG_UNIFORM_BUFFER
+	for (int k = 0; k < sizeof(float); ++k)
+	{
+		ENSURE(*(m_UBOSourceBuffer.data() + offset + 0 * sizeof(float) + k) == 0xFD);
+		ENSURE(*(m_UBOSourceBuffer.data() + offset + 1 * sizeof(float) + k) == 0xFD);
+	}
+#endif // DEBUG_UNIFORM_BUFFER
+	*((float*)(m_UBOSourceBuffer.data() + offset + 0 * sizeof(float))) = v.X;
+	*((float*)(m_UBOSourceBuffer.data() + offset + 1 * sizeof(float))) = v.Y;
+}
+
+void InterfaceBlock::SetUniform(const UniformBinding& id, size_t count, const CMatrix3D* v, GLuint instanceId)
+{	
+	//   mat0  mat1  mat2  mat3 ..64
+	// [[0123][0123][0123][0123]....]  Inst0
+	// [[0123][0123][0123][0123]....]  Inst1
+	// [[0123][0123][0123][0123]....]  Inst2
+	// [[0123][0123][0123][0123]....]  Inst3
+	// [[0123][0123][0123][0123]....]  Inst4
+	// ... 
+	CMatrix3D* ptr = const_cast<CMatrix3D*>(v);
+	GLint memberOffset = GetMemberProp(id.m_UniformId, PROPS::PROP_OFFSET);
+	
+	m_UBODirtyBytes = std::max((size_t)m_UBODirtyBytes, 
+		(size_t)(memberOffset +  64 * GetMemberProp(id.m_UniformId, PROPS::PROP_ARRAY_STRIDE) * (instanceId + 1)));
+	
+	if (m_UBOBlockSize < m_UBODirtyBytes)
+		IncreaseBufferSize(m_UBODirtyBytes);
+	
+	// NOTE: Make sure not to move this line before IncreaseBufferSize because it might invalidate the pointer!
+	GLubyte* dstPtr = (m_UBOSourceBuffer.data() + memberOffset);
+	// TODO: 64 is MAX_BONES bones in the shader... need a way to query this
+	dstPtr += 64 * GetMemberProp(id.m_UniformId, PROPS::PROP_ARRAY_STRIDE) * instanceId; // point to current instance
+	
+	for (int h=0; h<count; ++h) // current matrix
+	{		
+		for (int i=0; i<4; ++i) // current matrix column/row of the current matrix
+		{
+			GLuint offset = GetMemberProp(id.m_UniformId, PROPS::PROP_MATRIX_STRIDE) * i;
+			for (int j=0; j<4; ++j)
+			{
+				float value = (*ptr)[i * 4 + j];
+				
+#if DEBUG_UNIFORM_BUFFER
+				for (int k = 0; k < sizeof(float); ++k)
+					ENSURE(*(dstPtr + offset + k) == 0xFD);
+#endif // DEBUG_UNIFORM_BUFFER
+
+				*((float*)(dstPtr + offset)) = value;
+				offset += sizeof(GLfloat);
+			}	
+		}
+		ptr++; // points to the current matrix in src
+		dstPtr += GetMemberProp(id.m_UniformId, PROPS::PROP_ARRAY_STRIDE);
+		if (h == 63)
+			break;
+	}
+	
+	/*
+	if (id.first != -1)
+	{
+		if (id.second == GL_FLOAT_MAT4)
+			pglUniformMatrix4fvARB(id.first, count, GL_FALSE, &v->_11);
+		else
+			LOGERROR("CShaderProgramGLSL::Uniform(): Invalid uniform type (expected mat4)");
+	}*/
+}
+
+void InterfaceBlock::SetUniform(const UniformBinding& id, float v, GLuint instanceId)
+{
+	GLuint offset = GetMemberProp(id.m_UniformId, PROPS::PROP_OFFSET) + GetMemberProp(id.m_UniformId, PROPS::PROP_ARRAY_STRIDE) * instanceId;
+	m_UBODirtyBytes = std::max((size_t)m_UBODirtyBytes, (size_t)(offset + 1 * sizeof(float)));
+	
+	if (m_UBOBlockSize < m_UBODirtyBytes)
+		IncreaseBufferSize(m_UBODirtyBytes);
+
+#if DEBUG_UNIFORM_BUFFER
+for (int i = 0; i < sizeof(float); ++i)
+	ENSURE(*(m_UBOSourceBuffer.data() + offset + i) == 0xFD);
+#endif // DEBUG_UNIFORM_BUFFER
+	*((float*)(m_UBOSourceBuffer.data() + offset)) = v;
+}
+
+void InterfaceBlock::SetUniformF4(UniformBinding id, float v0, float v1, float v2, float v3, GLuint instanceId)
+{
+	if (id.m_Type == GL_FLOAT)
+		SetUniform(id, v0, instanceId);
+	else if (id.m_Type == GL_FLOAT_VEC2)
+		SetUniform(id, CVector2D(v0, v1), instanceId);//pglUniform2fARB(id.m_Type, v0, v1);
+	else if (id.m_Type == GL_FLOAT_VEC3)
+		SetUniform(id, CVector3D(v0, v1, v2), instanceId); //pglUniform3fARB(id.m_Type, v0, v1, v2);
+	else if (id.m_Type == GL_FLOAT_VEC4)
+		SetUniform(id, CVector4D(v0, v1, v2, v3), instanceId); //pglUniform4fARB(id.m_Type, v0, v1, v2, v3);*/
+	else
+		LOGERROR("CShaderProgramGLSL::Uniform(): Invalid uniform type (expected float, vec2, vec3, vec4)");
+}
+
+void InterfaceBlock::Upload()
+{
+	ENSURE(m_UBOBlockSize >= m_UBODirtyBytes);
+	/*
+	if (m_BlockName.string() == "ModelUBO")
+	{
+		std::ofstream myfile;
+		myfile.open ("dumpfile.txt", std::fstream::out | std::fstream::app);
+		myfile << "start...\n";
+		for (int i=0, drawIx=0; i < (m_UBOBlockSize); i += m_MemberProps[PROPS::PROP_ARRAY_STRIDE], ++drawIx)
+		{
+			if (*(GLuint*)&(m_UBOSourceBuffer.data()[i]) == 1110)
+			{
+			myfile << drawIx << ": " << *(GLuint*)&(m_UBOSourceBuffer.data()[i]) << " ";
+			if (i%99 == 0)
+				myfile << "\n";
+			}
+		}
+		
+		myfile << "...end\n\n\n";
+  		myfile.close();
+	}*/
+	pglBindBufferARB(m_MemberBufferType, m_UBOBufferID);
+	
+	// Resize the buffer on the graphics card if the source buffer had to be resized
+	if (m_BufferResized)
+	{
+		pglBufferDataARB(m_MemberBufferType, m_UBOBlockSize, m_UBOSourceBuffer.data(), GL_DYNAMIC_DRAW);
+		m_BufferResized = false;
+	}
+	else
+	{
+		pglBufferSubDataARB(m_MemberBufferType, 0, m_UBODirtyBytes, m_UBOSourceBuffer.data());
+	}
+	m_UBODirtyBytes = 0;
+#if DEBUG_UNIFORM_BUFFER
+	memset(m_UBOSourceBuffer.data(), 0xFD, m_UBOBlockSize);
+#endif // DEBUG_UNIFORM_BUFFER
+}
+
+/**
+ * Gets a binding from a uniform name
+ * The idea is to call GetBinding once and then use only the binding because that's faster.
+ */
+// TODO: check GetUniformVertexIndex in ShaderProgram.cpp.
+// It might make sense to store to use an std::map for the mapping too
+void InterfaceBlock::GetBinding(UniformBinding& id, CStrIntern uniformName) const
+{
+	auto it = std::find(m_UniformNames.begin(), m_UniformNames.end(), uniformName);
+	if (it == m_UniformNames.end())
+	{
+		// TODO: Better error handling. Uniforms can be disabled due to shader defines, so
+		// it's not necessarily an error if we can't find the uniform binding.
+		//std::cerr << "ERROR: Unknown uniform name." << uniformName.c_str() << std::endl;
+		return;
+	}
+
+	id.m_BlockType = m_InterfaceBlockType;
+	int pos = std::distance(m_UniformNames.begin(), it);
+	id.m_UniformId = pos; // TODO: third (type) not used yet
+	id.m_Type = m_UniformTypes[pos];
+}
+
+// Explicit instantiation is required for the allowed block identifier types
+//template void InterfaceBlock::GetBlockIdentifiers<GL_UNIFORM_BLOCK>(GLuint program, std::vector<InterfaceBlockIdentifier>& out);
+//template void InterfaceBlock::GetBlockIdentifiers<GL_SHADER_STORAGE_BLOCK>(GLuint program, std::vector<InterfaceBlockIdentifier>& out);
diff --git a/source/graphics/UniformBuffer.h b/source/graphics/UniformBuffer.h
new file mode 100644
index 0000000..eda2844
--- /dev/null
+++ b/source/graphics/UniformBuffer.h
@@ -0,0 +1,218 @@
+/* Copyright (C) 2015 Wildfire Games.
+ * This file is part of 0 A.D.
+ *
+ * 0 A.D. is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * 0 A.D. is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with 0 A.D.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef INCLUDED_UNIFORMBUFFER
+#define INCLUDED_UNIFORMBUFFER
+
+#include <iostream>
+#include <vector>
+#include <memory>
+#include <algorithm>
+
+#include "lib/ogl.h"
+
+
+#include "maths/Matrix3D.h"
+#include "maths/Vector2D.h"
+#include "ps/Shapes.h" // CColor
+#include "ps/CStrIntern.h"
+#include "graphics/UniformBinding.h"
+
+//#include "ps/Profile.h"
+
+class CShaderProgram;
+//class UniformBinding;
+
+#define  DEBUG_UNIFORM_BUFFER 0
+
+/**
+ * A uniform buffer holds data for one type of uniform block which can be used across multiple different shaders.
+ * The buffer gets prepared in RAM by a series of calls to SetUniform and then the whole buffer data is uploaded 
+ * to the uniform buffer on the GPU.
+ *
+ */
+class InterfaceBlock
+{
+public:
+	InterfaceBlock(GLuint program, const InterfaceBlockIdentifier& blockIdentifier, const int InterfaceBlockType);
+	
+	// A uniform buffer owns memory. It can be moved but not copied.
+	InterfaceBlock(const InterfaceBlock&) = delete;
+	InterfaceBlock(InterfaceBlock&&) = default;
+	
+	//template <int BLOCKTYPE>
+	//static void GetBlockIdentifiers(GLuint program, std::vector<InterfaceBlockIdentifier>& out);
+	static void GetBlockIdentifiers(GLuint program, std::vector<InterfaceBlockIdentifier>& out,
+		int& numUBOBlocks, int& numSSBOBlocks);
+	
+	/**
+	 * @param id: id.first contains a number identifying the uniform in the block 
+	 * (between 0 and the number of uniforms in this block). 
+	 */
+	
+	 /*
+	void SetUniform(Binding id, GLuint instanceID, CMatrix3D matrix);
+	void SetUniform(Binding id, CMatrix3D matrix);
+	void SetUniform(Binding id, float v);
+	*/
+	
+	// TODO: More templated?
+	inline void SetUniform(const UniformBinding& id, CColor& v, GLuint instanceId);
+	inline void SetUniform(const UniformBinding& id, CMatrix3D matrix, GLuint instanceId);
+	void SetUniform(const UniformBinding& id, CVector4D v, GLuint instanceId);
+	void SetUniform(const UniformBinding& id, CVector3D v, GLuint instanceId);
+	void SetUniform(const UniformBinding& id, CVector2D v, GLuint instanceId);
+	void SetUniform(const UniformBinding& id, float v, GLuint instanceId);
+	inline void SetUniform(const UniformBinding& id, GLuint v, GLuint instanceId);
+	
+	/**
+	 * Sets an instanced array of matrices (array of array of matrices).
+	 */
+	void SetUniform(const UniformBinding& id, size_t count, const CMatrix3D* v, GLuint instanceId);
+	
+	/**
+	 * Always takes 4 float values, but converts them according to the type determined by id and calls 
+	 * the appropriate SetUniform overload.
+	 * Supported types: float, vec2, vec3 and vec4
+	 */
+	void SetUniformF4(UniformBinding id, float v0, float v1, float v2, float v3, GLuint instanceId);
+	
+	void Upload();
+	
+	void GetBinding(UniformBinding& id, CStrIntern uniformName) const;
+	
+	GLuint m_UBOBufferID; // TODO: should be private in the final code
+
+private:
+	int m_InterfaceBlockType;
+	int m_MemberType;
+	int m_MemberBufferType;
+	
+	GLint m_UBOBlockSize;
+	bool m_BufferResized;
+	
+	// TODO: Using a vector is most convenient for resizing the buffer. However, I'm not sure if using resize could
+	// cause the vector capacity to be significantly larger than the requested size. In this use case, we should control
+	// when we need to acquire how much more memory and not a generic vector class.
+	std::vector<GLubyte> m_UBOSourceBuffer;
+	//std::unique_ptr<GLubyte> m_UBOSourceBuffer;
+	
+	std::vector<CStrIntern> m_UniformNames;
+	std::vector<int> m_UniformTypes;
+	std::vector<GLuint> m_UniformIndices;
+	
+	static constexpr GLenum MemberProps[] { GL_OFFSET, GL_ARRAY_STRIDE, GL_MATRIX_STRIDE };
+	enum PROPS { PROP_OFFSET, PROP_ARRAY_STRIDE, PROP_MATRIX_STRIDE, COUNT };
+	std::vector<GLint> m_MemberProps;
+	
+	// The data is laid out so that data for one member are stored together.
+	// This might theoretically improve caching
+	inline GLint GetMemberProp(int memberIx, PROPS prop) { return m_MemberProps[memberIx * PROPS::COUNT + prop]; }
+	
+	void IncreaseBufferSize(GLint minRequiredBlockSize)
+	{
+		// Increase buffer size to the required minimum block size, but at least by 10%
+		m_UBOBlockSize = std::max(GLint(m_UBOBlockSize * 1.1), minRequiredBlockSize);
+		m_UBOSourceBuffer.resize(m_UBOBlockSize);
+		m_BufferResized = true;
+	}
+	
+	GLint m_UBODirtyBytes; // upper bound of modified content
+public:
+	CStrIntern m_BlockName;
+};
+
+inline void InterfaceBlock::SetUniform(const UniformBinding& id, CColor& v, GLuint instanceId)
+{
+	//PROFILE3("SetUniform (CColor&)");
+	GLuint offset = GetMemberProp(id.m_UniformId, PROPS::PROP_OFFSET) + GetMemberProp(id.m_UniformId, PROPS::PROP_ARRAY_STRIDE) * instanceId;
+	m_UBODirtyBytes = std::max((size_t)m_UBODirtyBytes, (size_t)(offset + 3 * sizeof(float)));
+	
+	if (m_UBOBlockSize < m_UBODirtyBytes)
+		IncreaseBufferSize(m_UBODirtyBytes);
+
+#if DEBUG_UNIFORM_BUFFER
+	for (int k = 0; k < sizeof(float); ++k)
+	{
+		ENSURE(*(m_UBOSourceBuffer.data() + offset + 0 * sizeof(float) + k) == 0xFD);
+		ENSURE(*(m_UBOSourceBuffer.data() + offset + 1 * sizeof(float) + k) == 0xFD);
+		ENSURE(*(m_UBOSourceBuffer.data() + offset + 2 * sizeof(float) + k) == 0xFD);
+	}
+#endif // DEBUG_UNIFORM_BUFFER
+	*((float*)(m_UBOSourceBuffer.data() + offset + 0 * sizeof(float))) = v.r;
+	*((float*)(m_UBOSourceBuffer.data() + offset + 1 * sizeof(float))) = v.g;
+	*((float*)(m_UBOSourceBuffer.data() + offset + 2 * sizeof(float))) = v.b;
+	
+	// TODO: What if we need the alpha-channel?
+	//*((float*)(m_UBOSourceBuffer.data() + offset + 3 * sizeof(float))) = v.a;
+}
+
+inline void InterfaceBlock::SetUniform(const UniformBinding& id, GLuint v, GLuint instanceId)
+{
+	//PROFILE3("SetUniform (GLuint)");
+	GLuint offset = GetMemberProp(id.m_UniformId, PROPS::PROP_OFFSET) + GetMemberProp(id.m_UniformId, PROPS::PROP_ARRAY_STRIDE) * instanceId;
+	
+	m_UBODirtyBytes = std::max((size_t)m_UBODirtyBytes, (size_t)(offset + 1 * sizeof(GLuint)));
+
+	if (m_UBOBlockSize < m_UBODirtyBytes)
+		IncreaseBufferSize(m_UBODirtyBytes);
+
+#if DEBUG_UNIFORM_BUFFER
+	for (int k = 0; k < sizeof(GLuint); ++k)
+		ENSURE(*(m_UBOSourceBuffer.data() + offset + k) == 0xFD);
+#endif // DEBUG_UNIFORM_BUFFER
+	*((GLuint*)(m_UBOSourceBuffer.data() + offset)) = v;
+}
+
+inline void InterfaceBlock::SetUniform(const UniformBinding& id, CMatrix3D matrix, GLuint instanceId)
+{
+	//PROFILE3("SetUniform (CMatrix3D)");
+	/*
+	GLuint offset;
+	for (int i=0; i<4; ++i)
+	{
+		offset = GetMemberProp(id.m_UniformId, PROPS::PROP_OFFSET) + GetMemberProp(id.m_UniformId, PROPS::PROP_MATRIX_STRIDE) * i;
+		for (int j=0; j<4; ++j)
+		{
+#if DEBUG_UNIFORM_BUFFER
+			for (int k = 0; k < sizeof(float); ++k)
+				ENSURE(*(m_UBOSourceBuffer.data() + GetMemberProp(id.m_UniformId, PROPS::PROP_ARRAY_STRIDE) * instanceId + offset + k) == 0xFD);
+#endif // DEBUG_UNIFORM_BUFFER
+			*((float*)(m_UBOSourceBuffer.data() + GetMemberProp(id.m_UniformId, PROPS::PROP_ARRAY_STRIDE) * instanceId + offset)) = matrix[i * 4 + j];
+			offset += sizeof(GLfloat);
+		}	
+	}
+	
+	m_UBODirtyBytes = std::max((size_t)m_UBODirtyBytes, (size_t)(GetMemberProp(id.m_UniformId, PROPS::PROP_ARRAY_STRIDE) * instanceId + offset));
+	*/
+	
+	GLubyte* dstPtr = m_UBOSourceBuffer.data() + GetMemberProp(id.m_UniformId, PROPS::PROP_OFFSET) + GetMemberProp(id.m_UniformId, PROPS::PROP_ARRAY_STRIDE) * instanceId;
+	m_UBODirtyBytes = std::max((size_t)m_UBODirtyBytes, (size_t)(GetMemberProp(id.m_UniformId, PROPS::PROP_OFFSET) + GetMemberProp(id.m_UniformId, PROPS::PROP_ARRAY_STRIDE) * (instanceId + 1)));
+	
+	if (m_UBOBlockSize < m_UBODirtyBytes)
+		IncreaseBufferSize(m_UBODirtyBytes);
+	
+	for (int i=0; i<4; ++i)
+	{
+		for (int j=0; j<4; ++j)
+			*(float*)(dstPtr + j * sizeof(GLfloat)) = matrix[i * 4 + j];
+		dstPtr += GetMemberProp(id.m_UniformId, PROPS::PROP_MATRIX_STRIDE);
+	}
+}
+
+
+#endif // INCLUDED_UNIFORMBUFFER
\ No newline at end of file
diff --git a/source/lib/external_libraries/glext_funcs.h b/source/lib/external_libraries/glext_funcs.h
index 2b69231..16c3ae0 100644
--- a/source/lib/external_libraries/glext_funcs.h
+++ b/source/lib/external_libraries/glext_funcs.h
@@ -341,6 +341,9 @@ FUNC2(void, glUniform4uivEXT, glUniform4uiv, "3.0", (GLint location, GLsizei cou
 FUNC2(void, glGetUniformuivEXT, glGetUniformuiv, "3.0", (GLuint program, GLint location, GLuint *params))
 FUNC2(void, glBindFragDataLocationEXT, glBindFragDataLocation, "3.0", (GLuint program, GLuint colorNumber, const char *name))
 FUNC2(GLint, glGetFragDataLocationEXT, glGetFragDataLocation, "3.0", (GLuint program, const char *name))
+FUNC2(void, glBindBufferBase, glBindBufferBase, "3.0", (GLenum target, GLuint index, GLuint buffer))
+FUNC2(void, glGenVertexArrays, glGenVertexArrays, "3.0", (GLsizei n, GLuint* arrays))
+FUNC2(void, glBindVertexArray, glBindVertexArray, "3.0", (GLuint array))
 
 // GL_ARB_occlusion_query / GL1.5:
 FUNC2(void, glGenQueriesARB, glGenQueries, "1.5", (GLsizei n, GLuint *ids))
@@ -352,6 +355,22 @@ FUNC2(void, glGetQueryivARB, glGetQueryiv, "1.5", (GLenum target, GLenum pname,
 FUNC2(void, glGetQueryObjectivARB, glGetQueryObjectiv, "1.5", (GLuint id, GLenum pname, GLint *params))
 FUNC2(void, glGetQueryObjectuivARB, glGetQueryObjectuiv, "1.5", (GLuint id, GLenum pname, GLuint *params))
 
+// GL3.1
+FUNC2(void, glGetActiveUniformsiv, glGetActiveUniformsiv, "3.1", (GLuint program, GLsizei uniformCount, const GLuint *uniformIndices, GLenum pname, GLint *params))
+FUNC2(void, glGetActiveUniformBlockiv, glGetActiveUniformBlockiv, "3.1", (GLuint program, GLuint uniformBlockIndex, GLenum pname, GLint *params))
+FUNC2(void, glGetActiveUniformBlockName, glGetActiveUniformBlockName, "3.1", (GLuint program,  GLuint uniformBlockIndex,  GLsizei bufSize,  GLsizei *length,  GLchar *uniformBlockName))
+FUNC2(void, glUniformBlockBinding, glUniformBlockBinding, "3.1", (GLuint program, GLuint uniformBlockIndex, GLuint uniformBlockBinding))
+
+// GL4.3
+FUNC2(void, glVertexBindingDivisor, glVertexBindingDivisor, "4.3", (GLuint bindingindex, GLuint divisor))
+FUNC2(void, glMultiDrawElementsIndirect, glMultiDrawElementsIndirect, "4.3", (GLenum mode, GLenum type, const void* indirect, GLsizei drawcount, GLsizei stride))
+FUNC2(void, glGetProgramInterfaceiv, glGetProgramInterfaceiv, "4.3", (GLuint program, GLenum programInterface, GLenum pname, GLint* params))
+FUNC2(void, glGetProgramResourceiv, glGetProgramResourceiv, "4.3", (GLuint program, GLenum programInterface, GLuint index, GLsizei propCount, const GLenum* props, GLsizei buffSize, GLsizei* length, GLint* params))
+FUNC2(void, glGetProgramResourceName, glGetProgramResourceName, "4.3", (GLuint program, GLenum programInterface, GLuint index, GLsizei bufSize, GLsizei* length, char* name))
+FUNC2(void, glShaderStorageBlockBinding, glShaderStorageBlockBinding, "4.3", (GLuint program, GLuint storageBlockIndex,	GLuint storageBlockBinding))
+FUNC2(GLuint, glGetProgramResourceIndex, glGetProgramResourceIndex, "4.3", (GLuint program, GLenum programInterface, const char* name))
+
+
 // GL_ARB_sync / GL3.2:
 FUNC2(void, glGetInteger64v, glGetInteger64v, "3.2", (GLenum pname, GLint64 *params))
 
diff --git a/source/ps/CStrInternStatic.h b/source/ps/CStrInternStatic.h
index 1f6bfad..2933e09 100644
--- a/source/ps/CStrInternStatic.h
+++ b/source/ps/CStrInternStatic.h
@@ -66,6 +66,7 @@ X(WATERTYPE_CLAP)
 X(WATERTYPE_LAKE)
 X2(_emptystring, "")
 X(a_apexPosition)
+X(a_drawId)
 X(a_otherPosition)
 X(a_retreatPosition)
 X(a_skinJoints)
@@ -99,6 +100,7 @@ X(gui_text)
 X(hdr)
 X(height)
 X(instancingTransform)
+X2(instancingTransform_0, "instancingTransform[0]")
 X(losMap)
 X(losMatrix)
 X(losTex)
@@ -109,6 +111,7 @@ X(los_interp)
 X(mapSize)
 X(maskTex)
 X(minimap)
+X2(modelId_0, "modelId[0]")
 X(modelViewMatrix)
 X(murkiness)
 X(normalMap)
@@ -118,6 +121,7 @@ X(overlay_solid)
 X(particle)
 X(particle_solid)
 X(playerColor)
+X2(playerColor_0, "playerColor[0]")
 X(pointSize)
 X(qualityLevel)
 X(reflectionMap)
@@ -130,11 +134,13 @@ X2(sans_10, "sans-10");
 X(saturation)
 X(screenSize)
 X(shadingColor)
+X2(shadingColor_0, "shadingColor[0]")
 X(shadowScale)
 X(shadowTex)
 X(shadowTransform)
 X(skinBlendMatrices)
 X2(skinBlendMatrices_0, "skinBlendMatrices[0]")
+X2(skinBlendMatrices_0_0, "skinBlendMatrices[0][0]")
 X(skyBoxRot)
 X(skyCube)
 X(sky_simple)
diff --git a/source/renderer/InstancingModelRenderer.cpp b/source/renderer/InstancingModelRenderer.cpp
index 0355774..86d65fe 100644
--- a/source/renderer/InstancingModelRenderer.cpp
+++ b/source/renderer/InstancingModelRenderer.cpp
@@ -26,11 +26,14 @@
 #include "maths/Vector4D.h"
 
 #include "ps/CLogger.h"
+#include "ps/Profile.h"
+
 
 #include "graphics/Color.h"
 #include "graphics/LightEnv.h"
 #include "graphics/Model.h"
 #include "graphics/ModelDef.h"
+#include "graphics/UniformBlockManager.h"
 
 #include "renderer/InstancingModelRenderer.h"
 #include "renderer/Renderer.h"
@@ -258,6 +261,8 @@ struct InstancingModelRendererInternals
 
 	/// Index base for imodeldef
 	u8* imodeldefIndexBase;
+	
+	MultiDrawIndirectCommands multiDrawIndirectCommands;
 };
 
 
@@ -325,6 +330,12 @@ void InstancingModelRenderer::PrepareModelDef(const CShaderProgramPtr& shader, i
 
 	u8* base = m->imodeldef->m_Array.Bind();
 	GLsizei stride = (GLsizei)m->imodeldef->m_Array.GetStride();
+	
+	// HACK: Hardcode the vertex attribute to 15 (gl_MultiTexCoord7) because that doesn't seem to be
+	// used anywhere currently
+	u8* instancingDataBasePtr = m->imodeldef->m_Array.GetInstancingDataBasePtr();
+	pglVertexAttribIPointerEXT(15, 1, GL_UNSIGNED_INT, 0, (const GLvoid*)instancingDataBasePtr);
+	pglVertexBindingDivisor(15, 1);
 
 	m->imodeldefIndexBase = m->imodeldef->m_IndexArray.Bind();
 
@@ -353,12 +364,31 @@ void InstancingModelRenderer::PrepareModelDef(const CShaderProgramPtr& shader, i
 	shader->AssertPointersBound();
 }
 
+void InstancingModelRenderer::PrepareModel(const CShaderProgramPtr& shader, CModel* model)
+{
+	UniformBlockManager& uniformBlockManager = g_Renderer.GetUniformBlockManager();
+	if (m->gpuSkinning)
+	{
+		CModelDefPtr mdldef = model->GetModelDef();
+		
+		// Bind matrices for current animation state.
+		// Add 1 to NumBones because of the special 'root' bone.
+		// HACK: NVIDIA drivers return uniform name with "[0]", Intel Windows drivers without;
+		// try uploading both names since one of them should work, and this is easier than
+		// canonicalising the uniform names in CShaderProgramGLSL
+		UniformBinding binding = uniformBlockManager.GetBinding(CStrIntern("GPUSkinningUBO"), str_skinBlendMatrices_0, true);
+		uniformBlockManager.SetUniform<UniformBlockManager::MODEL_INSTANCED>(binding, mdldef->GetNumBones() + 1, model->GetAnimatedBoneMatrices());
+		//shader->Uniform(str_skinBlendMatrices_0, mdldef->GetNumBones() + 1, model->GetAnimatedBoneMatrices());
+		//shader->Uniform(str_skinBlendMatrices, mdldef->GetNumBones() + 1, model->GetAnimatedBoneMatrices());
+	}
+}
 
 // Render one model
 void InstancingModelRenderer::RenderModel(const CShaderProgramPtr& shader, int UNUSED(streamflags), CModel* model, CModelRData* UNUSED(data))
 {
+	
 	CModelDefPtr mdldef = model->GetModelDef();
-
+	/*
 	if (m->gpuSkinning)
 	{
 		// Bind matrices for current animation state.
@@ -368,7 +398,7 @@ void InstancingModelRenderer::RenderModel(const CShaderProgramPtr& shader, int U
 		// canonicalising the uniform names in CShaderProgramGLSL
 		shader->Uniform(str_skinBlendMatrices_0, mdldef->GetNumBones() + 1, model->GetAnimatedBoneMatrices());
 		shader->Uniform(str_skinBlendMatrices, mdldef->GetNumBones() + 1, model->GetAnimatedBoneMatrices());
-	}
+	}*/
 
 	// render the lot
 	size_t numFaces = mdldef->GetNumFaces();
@@ -389,3 +419,75 @@ void InstancingModelRenderer::RenderModel(const CShaderProgramPtr& shader, int U
 	g_Renderer.m_Stats.m_ModelTris += numFaces;
 
 }
+
+// TODO: there are too many functions here that do nothing else than forwarding
+// the functions from multiDrawIndirectCommands.
+
+
+void InstancingModelRenderer::ResetDrawID()
+{
+	m->multiDrawIndirectCommands.ResetDrawID();
+}
+
+void InstancingModelRenderer::ResetCommands()
+{
+	m->multiDrawIndirectCommands.ResetCommands();
+}
+
+
+void InstancingModelRenderer::AddInstance()
+{
+	m->multiDrawIndirectCommands.AddInstance();
+}
+
+void InstancingModelRenderer::BindAndUpload()
+{
+		m->multiDrawIndirectCommands.BindAndUpload();
+}
+
+void InstancingModelRenderer::RenderModelsInstanced(u32 modelsCount)
+{
+	if (!g_Renderer.m_SkipSubmit)
+		m->multiDrawIndirectCommands.Draw(modelsCount);
+}
+
+void InstancingModelRenderer::SetRenderModelInstanced(const CShaderProgramPtr& shader, int UNUSED(streamflags), CModel* model, CModelRData* UNUSED(data))
+{
+	/*
+	CModelDefPtr mdldef = model->GetModelDef();
+
+	if (m->gpuSkinning)
+	{
+		// Bind matrices for current animation state.
+		// Add 1 to NumBones because of the special 'root' bone.
+		// HACK: NVIDIA drivers return uniform name with "[0]", Intel Windows drivers without;
+		// try uploading both names since one of them should work, and this is easier than
+		// canonicalising the uniform names in CShaderProgramGLSL
+		shader->Uniform(str_skinBlendMatrices_0, mdldef->GetNumBones() + 1, model->GetAnimatedBoneMatrices());
+		shader->Uniform(str_skinBlendMatrices, mdldef->GetNumBones() + 1, model->GetAnimatedBoneMatrices());
+	}*/
+
+	CModelDefPtr mdldef = model->GetModelDef();
+	
+	size_t numFaces = mdldef->GetNumFaces();
+	
+	//u64 indexBase = (u64)m->imodeldefIndexBase;
+	//indexBase = indexBase / 2;
+	
+	IModelDef* imodeldef = (IModelDef*)mdldef->GetRenderData(m);
+	ENSURE(imodeldef);
+	u8* imodeldefIndexBase = imodeldef->m_IndexArray.GetBindAddress();
+	// Hardcoded sizeof(index-buffer-element-type) as 2 byte assuming u16
+	size_t imodeldefIndexBaseUnit = (size_t)imodeldefIndexBase / 2;
+	
+	
+	m->multiDrawIndirectCommands.AddCommand((GLsizei)numFaces*3, // primCount
+											1, // instanceCount
+											imodeldefIndexBaseUnit, // m->imodeldefIndexBase, // firstIndex
+											0); // baseVertex... I guess that should be 0 because the offset for instancing data was already passed to glVertexPinter
+
+	// bump stats
+	g_Renderer.m_Stats.m_DrawCalls++; // TODO: how with instancing...?
+	g_Renderer.m_Stats.m_ModelTris += numFaces;
+
+}
diff --git a/source/renderer/InstancingModelRenderer.h b/source/renderer/InstancingModelRenderer.h
index 2517291..32a70dd 100644
--- a/source/renderer/InstancingModelRenderer.h
+++ b/source/renderer/InstancingModelRenderer.h
@@ -45,6 +45,13 @@ public:
 	void BeginPass(int streamflags);
 	void EndPass(int streamflags);
 	void PrepareModelDef(const CShaderProgramPtr& shader, int streamflags, const CModelDef& def);
+	void ResetDrawID();
+	void ResetCommands();
+	void AddInstance();
+	void SetRenderModelInstanced(const CShaderProgramPtr& shader, int UNUSED(streamflags), CModel* model, CModelRData* UNUSED(data));
+	void RenderModelsInstanced(u32 modelsCount);
+	void BindAndUpload();
+	void PrepareModel(const CShaderProgramPtr& shader, CModel* model);
 	void RenderModel(const CShaderProgramPtr& shader, int streamflags, CModel* model, CModelRData* data);
 
 protected:
diff --git a/source/renderer/ModelRenderer.cpp b/source/renderer/ModelRenderer.cpp
index be385dc..a5eab01 100644
--- a/source/renderer/ModelRenderer.cpp
+++ b/source/renderer/ModelRenderer.cpp
@@ -31,8 +31,11 @@
 #include "graphics/Material.h"
 #include "graphics/Model.h"
 #include "graphics/ModelDef.h"
+#include "graphics/MultiDrawIndirectCommands.h"
 #include "graphics/ShaderManager.h"
 #include "graphics/TextureManager.h"
+#include "graphics/UniformBlockManager.h"
+#include "graphics/ShaderBlockUniforms.h"
 
 #include "renderer/MikktspaceWrap.h"
 #include "renderer/ModelRenderer.h"
@@ -215,6 +218,15 @@ struct ShaderModelRendererInternals
 
 	/// List of submitted models for rendering in this frame
 	std::vector<CModel*> submissions[CRenderer::CULL_MAX];
+	
+	struct HeapCounters
+	{
+		HeapCounters() : pass(0), idx(0), idxTechStart(0), modelIx(0) {}
+		size_t pass;
+		size_t idx;
+		size_t idxTechStart;
+		size_t modelIx;
+	} heapCounters;
 };
 
 
@@ -345,16 +357,6 @@ struct SMRMaterialBucketKeyHash
 	}
 };
 
-struct SMRTechBucket
-{
-	CShaderTechniquePtr tech;
-	CModel** models;
-	size_t numModels;
-
-	// Model list is stored as pointers, not as a std::vector,
-	// so that sorting lists of this struct is fast
-};
-
 struct SMRCompareTechBucket
 {
 	bool operator()(const SMRTechBucket& a, const SMRTechBucket& b)
@@ -363,6 +365,126 @@ struct SMRCompareTechBucket
 	}
 };
 
+void ShaderModelRenderer::PrepareUniformBuffers(size_t maxInstancesPerDraw, int flags, 
+												const std::vector<SMRTechBucket, TechBucketsAllocator>& techBuckets, 
+												const RenderModifierPtr& modifier)
+{
+	PROFILE3("PrepareUniformBuffers");
+	UniformBlockManager& uniformBlockManager = g_Renderer.GetUniformBlockManager();
+	ENSURE(maxInstancesPerDraw != 0);
+	
+	size_t instanceId = 0;
+	u64 materialUniformsSet = 0;	
+
+	while (m->heapCounters.idxTechStart < techBuckets.size())
+	{
+		CShaderTechniquePtr currentTech = techBuckets[m->heapCounters.idxTechStart].tech;
+
+		// Find runs [idxTechStart, idxTechEnd) in techBuckets of the same technique
+		size_t idxTechEnd;
+		for (idxTechEnd = m->heapCounters.idxTechStart + 1; idxTechEnd < techBuckets.size(); ++idxTechEnd)
+		{
+			if (techBuckets[idxTechEnd].tech != currentTech)
+				break;
+		}
+
+		// For each of the technique's passes, render all the models in this run
+		while (true)
+		{
+			if (m->heapCounters.pass == currentTech->GetNumPasses())
+			{
+				m->heapCounters.pass = 0;
+				break;
+			}
+
+			const CShaderProgramPtr& shader = currentTech->GetShader(m->heapCounters.pass);
+			int streamflags = shader->GetStreamFlags();
+			
+			//for (size_t idx = idxTechStart; idx < idxTechEnd; ++idx)
+			
+			while (true)	
+			{
+				if (m->heapCounters.idx == idxTechEnd)
+				{
+					m->heapCounters.idx = m->heapCounters.idxTechStart;
+					break;
+				}
+				
+				CModel** models = techBuckets[m->heapCounters.idx].models;
+				size_t numModels = techBuckets[m->heapCounters.idx].numModels;
+				//for (size_t modelIx = 0; modelIx < numModels; ++modelIx)
+				
+				while (true)
+				{
+					if (m->heapCounters.modelIx == numModels)
+					{
+						m->heapCounters.modelIx = 0;
+						break;
+					}
+					
+					CModel* model = models[m->heapCounters.modelIx];
+
+					if (flags && !(model->GetFlags() & flags))
+					{
+						m->heapCounters.modelIx++;
+						continue;
+					}
+				
+					uniformBlockManager.SetCurrentInstance<UniformBlockManager::MODEL_INSTANCED>(instanceId);
+					
+					modifier->SetModelUniforms(model);
+					m->vertexRenderer->PrepareModel(shader, model);
+					
+					CModelRData* rdata = NULL;
+					m->vertexRenderer->SetRenderModelInstanced(shader, streamflags, model, rdata);
+					
+					instanceId++;
+					
+					if (instanceId == maxInstancesPerDraw)
+					{
+						PROFILE3("upload uniforms (1)");
+						uniformBlockManager.Upload();
+						m->vertexRenderer->BindAndUpload();
+						
+						// Rare case. If the final batch matches the remaining number of draws to prepare exactly
+						// (we would have returned anyway). In this case we must make sure to reset the counters on the heap.
+						if (m->heapCounters.modelIx == numModels && m->heapCounters.pass == currentTech->GetNumPasses() && m->heapCounters.idx + 1 == techBuckets.size())
+						{
+							m->heapCounters.modelIx = 0;
+							m->heapCounters.idx = 0;
+							m->heapCounters.pass = 0;
+							m->heapCounters.idxTechStart = 0;
+						}
+						else
+						{
+							m->heapCounters.modelIx++;
+						}
+						
+						return;
+					}
+					
+					m->heapCounters.modelIx++;
+						
+				}
+				m->heapCounters.idx++;
+			}
+			m->heapCounters.pass++;
+		}
+		m->heapCounters.idx = m->heapCounters.idxTechStart = idxTechEnd;
+	}
+	
+	{
+		PROFILE3("upload uniforms (2)");
+		uniformBlockManager.Upload();
+		m->vertexRenderer->BindAndUpload();
+		
+		m->heapCounters.modelIx = 0;
+		m->heapCounters.idx = 0;
+		m->heapCounters.pass = 0;
+		m->heapCounters.idxTechStart = 0;
+	}
+}
+
 void ShaderModelRenderer::Render(const RenderModifierPtr& modifier, const CShaderDefines& context, int cullGroup, int flags)
 {
 	if (m->submissions[cullGroup].empty())
@@ -494,7 +616,6 @@ void ShaderModelRenderer::Render(const RenderModifierPtr& modifier, const CShade
 		// if we just stored raw CShaderTechnique* and assumed the shader manager
 		// will keep it alive long enough)
 
-	typedef ProxyAllocator<SMRTechBucket, Allocators::DynamicArena> TechBucketsAllocator;
 	std::vector<SMRTechBucket, TechBucketsAllocator> techBuckets((TechBucketsAllocator(arena)));
 
 	{
@@ -601,6 +722,27 @@ void ShaderModelRenderer::Render(const RenderModifierPtr& modifier, const CShade
 
 		size_t idxTechStart = 0;
 		
+		size_t preparedModelUniformsLeft = 2000;
+		const size_t maxInstancesPerDraw = 2000;
+		
+		UniformBlockManager& uniformBlockManager = g_Renderer.GetUniformBlockManager();
+		
+		// Set all per-frame uniforms
+		UniformBinding binding = uniformBlockManager.GetBinding(CStrIntern("FrameUBO"), CStrIntern("sim_time"), false);
+		if (binding.Active())
+		{
+			double time = g_Renderer.GetTimeManager().GetGlobalTime();
+			// TODO: Why don't we just use a single float instead of vec4?
+			uniformBlockManager.SetUniform<UniformBlockManager::NOT_INSTANCED>(binding, CVector4D(time, 0, 0, 0));
+		}
+		
+		modifier->SetFrameUniforms();
+		
+		// prepare the first batch of uniforms.
+		// This causes an upload of all modified uniform buffers, and will also take care of uploading
+		// the per-frame uniforms
+		PrepareUniformBuffers(maxInstancesPerDraw, flags, techBuckets, modifier);
+		
 		// This vector keeps track of texture changes during rendering. It is kept outside the
 		// loops to avoid excessive reallocations. The token allocation of 64 elements 
 		// should be plenty, though it is reallocated below (at a cost) if necessary.
@@ -611,8 +753,8 @@ void ShaderModelRenderer::Render(const RenderModifierPtr& modifier, const CShade
 		// texBindings holds the identifier bindings in the shader, which can no longer be defined 
 		// statically in the ShaderRenderModifier class. texBindingNames uses interned strings to
 		// keep track of when bindings need to be reevaluated.
-		typedef ProxyAllocator<CShaderProgram::Binding, Allocators::DynamicArena> BindingListAllocator;
-		std::vector<CShaderProgram::Binding, BindingListAllocator> texBindings((BindingListAllocator(arena)));
+		typedef ProxyAllocator<Binding, Allocators::DynamicArena> BindingListAllocator;
+		std::vector<Binding, BindingListAllocator> texBindings((BindingListAllocator(arena)));
 		texBindings.reserve(64);
 
 		typedef ProxyAllocator<CStrIntern, Allocators::DynamicArena> BindingNamesListAllocator;
@@ -622,6 +764,12 @@ void ShaderModelRenderer::Render(const RenderModifierPtr& modifier, const CShade
 		while (idxTechStart < techBuckets.size())
 		{
 			CShaderTechniquePtr currentTech = techBuckets[idxTechStart].tech;
+			
+			// Set to true when a new instanced draw command gets added.
+			// Everytime we do a state-change that requires adding a new DrawElementsIndirectCommand,
+			// we have to set this to false
+			// TODO: Completely useless currently because we only ever draw one instance
+			bool sameInstance = false;
 
 			// Find runs [idxTechStart, idxTechEnd) in techBuckets of the same technique
 			size_t idxTechEnd;
@@ -638,6 +786,10 @@ void ShaderModelRenderer::Render(const RenderModifierPtr& modifier, const CShade
 
 				const CShaderProgramPtr& shader = currentTech->GetShader(pass);
 				int streamflags = shader->GetStreamFlags();
+				
+				// TODO: Check the return value and force drawing if it's false
+				// TODO: There should be a smarter way to figure out if bindings are already set up correctly.
+				uniformBlockManager.EnsureBlockBinding(shader);
 
 				modifier->BeginPass(shader);
 
@@ -659,34 +811,39 @@ void ShaderModelRenderer::Render(const RenderModifierPtr& modifier, const CShade
 					size_t numModels = techBuckets[idx].numModels;
 					for (size_t i = 0; i < numModels; ++i)
 					{
+
 						CModel* model = models[i];
+						
+						// TODO: Instancing is completely useless currently because we only ever draw one instance
+						sameInstance = false;
 
 						if (flags && !(model->GetFlags() & flags))
 							continue;
 
 						const CMaterial::SamplersVector& samplers = model->GetMaterial().GetSamplers();
 						size_t samplersNum = samplers.size();
-						
+						ogl_WarnIfError();
 						// make sure the vectors are the right virtual sizes, and also
 						// reallocate if there are more samplers than expected.
 						if (currentTexs.size() != samplersNum)
 						{
 							currentTexs.resize(samplersNum, NULL);
-							texBindings.resize(samplersNum, CShaderProgram::Binding());
+							texBindings.resize(samplersNum, Binding());
 							texBindingNames.resize(samplersNum, CStrIntern());
 							
 							// ensure they are definitely empty
-							std::fill(texBindings.begin(), texBindings.end(), CShaderProgram::Binding());
+							std::fill(texBindings.begin(), texBindings.end(), Binding());
 							std::fill(currentTexs.begin(), currentTexs.end(), (CTexture*)NULL);
 							std::fill(texBindingNames.begin(), texBindingNames.end(), CStrIntern());
 						}
 						
+						ogl_WarnIfError();
 						// bind the samplers to the shader
 						for (size_t s = 0; s < samplersNum; ++s)
 						{
 							const CMaterial::TextureSampler& samp = samplers[s];
 							
-							CShaderProgram::Binding bind = texBindings[s];
+							Binding bind = texBindings[s];
 							// check that the handles are current
 							// and reevaluate them if necessary
 							if (texBindingNames[s] == samp.Name && bind.Active())
@@ -708,6 +865,7 @@ void ShaderModelRenderer::Render(const RenderModifierPtr& modifier, const CShade
 								currentTexs[s] = newTex;
 							}
 						}
+						ogl_WarnIfError();
 						
 						// Bind modeldef when it changes
 						CModelDef* newModeldef = model->GetModelDef().get();
@@ -716,30 +874,48 @@ void ShaderModelRenderer::Render(const RenderModifierPtr& modifier, const CShade
 							currentModeldef = newModeldef;
 							m->vertexRenderer->PrepareModelDef(shader, streamflags, *currentModeldef);
 						}
-
+						ogl_WarnIfError();
+						//CShaderBlockUniforms& staticUniforms = model->GetMaterial().GetStaticBlockUniforms();
+						//staticUniforms.SetUniforms(uniformBlockManager);
+						/*
 						// Bind all uniforms when any change
 						CShaderUniforms newStaticUniforms = model->GetMaterial().GetStaticUniforms();
 						if (newStaticUniforms != currentStaticUniforms)
 						{
 							currentStaticUniforms = newStaticUniforms;
 							currentStaticUniforms.BindUniforms(shader);
-						}
+						}*/
 						
 						const CShaderRenderQueries& renderQueries = model->GetMaterial().GetRenderQueries();
 						
 						for (size_t q = 0; q < renderQueries.GetSize(); q++)
 						{
 							CShaderRenderQueries::RenderQuery rq = renderQueries.GetItem(q);
-							if (rq.first == RQUERY_TIME)
+							/*if (rq.first == RQUERY_TIME)
 							{
-								CShaderProgram::Binding binding = shader->GetUniformBinding(rq.second);
+								
+//								Binding binding = shader->GetUniformBinding(rq.second);
+//								if (binding.Active())
+//								{
+//									double time = g_Renderer.GetTimeManager().GetGlobalTime();
+//									shader->Uniform(binding, time, 0,0,0);
+//								}
+								
+								
+								// TODO: Could we just use a time value per frame and store it in a uniform block
+								// where all shaders can use it? With uniform blocks, RenderQueries only seem to
+								// make sense for per-object data.
+								UniformBinding binding = uniformBlockManager.GetBinding("TODO", rq.second);
+								binding.m_IsInstanced = false;
 								if (binding.Active())
 								{
 									double time = g_Renderer.GetTimeManager().GetGlobalTime();
-									shader->Uniform(binding, time, 0,0,0);
+									uniformBlockManager.SetUniform(binding, time, 0, 0, 0);
 								}
+								
+								
 							}
-							else if (rq.first == RQUERY_WATER_TEX)
+							else */if (rq.first == RQUERY_WATER_TEX)
 							{
 								WaterManager* WaterMgr = g_Renderer.GetWaterManager();
 								double time = WaterMgr->m_WaterTexTimer;
@@ -758,11 +934,26 @@ void ShaderModelRenderer::Render(const RenderModifierPtr& modifier, const CShade
 						}
 
 						modifier->PrepareModel(shader, model);
-
-						CModelRData* rdata = static_cast<CModelRData*>(model->GetRenderData());
-						ENSURE(rdata->GetKey() == m->vertexRenderer.get());
-
-						m->vertexRenderer->RenderModel(shader, streamflags, model, rdata);
+			
+						// TODO: will not need to be done for each models in the future		
+						m->vertexRenderer->RenderModelsInstanced(1);
+						//m->vertexRenderer->RenderModel(shader, streamflags, model, rdata);
+				
+						preparedModelUniformsLeft--;
+						if (preparedModelUniformsLeft == 0)
+						{
+							m->vertexRenderer->ResetDrawID();
+							m->vertexRenderer->ResetCommands();
+							PrepareUniformBuffers(maxInstancesPerDraw, flags, techBuckets, modifier);
+							
+							// technically not true when less models than maxInstancesPerDraw models are left, 
+							// but preparedModelUniformsLeft is only used to detect when PrepareUniformBuffers
+							// needs to be called, so it does not matter.
+							preparedModelUniformsLeft = maxInstancesPerDraw;
+							
+							// TODO: Force drawing (currently we draw always anyway, so it is already "forced",
+							// but this will change when instancing works properly)
+						}
 					}
 				}
 
@@ -774,4 +965,7 @@ void ShaderModelRenderer::Render(const RenderModifierPtr& modifier, const CShade
 			idxTechStart = idxTechEnd;
 		}
 	}
+	
+	m->vertexRenderer->ResetDrawID();
+	m->vertexRenderer->ResetCommands();
 }
diff --git a/source/renderer/ModelRenderer.h b/source/renderer/ModelRenderer.h
index c271184..fd19033 100644
--- a/source/renderer/ModelRenderer.h
+++ b/source/renderer/ModelRenderer.h
@@ -26,10 +26,15 @@
 
 #include <memory>
 
+#include "lib/allocators/allocator_adapters.h"
+#include "lib/allocators/arena.h"
+
 #include "graphics/MeshManager.h"
 #include "graphics/RenderableObject.h"
 #include "graphics/SColor.h"
+#include "graphics/ShaderManager.h"
 #include "renderer/VertexArray.h"
+#include "graphics/MultiDrawIndirectCommands.h"
 
 class RenderModifier;
 typedef shared_ptr<RenderModifier> RenderModifierPtr;
@@ -45,6 +50,7 @@ typedef shared_ptr<ModelRenderer> ModelRendererPtr;
 
 class CModel;
 class CShaderDefines;
+class MultiDrawIndirectCommands;
 
 /**
  * Class CModelRData: Render data that is maintained per CModel.
@@ -245,6 +251,18 @@ public:
 	static void GenTangents(const CModelDefPtr& mdef, std::vector<float>& newVertices, bool gpuSkinning);
 };
 
+// TODO: Make this a class member?
+struct SMRTechBucket
+{
+	CShaderTechniquePtr tech;
+	CModel** models;
+	size_t numModels;
+
+	// Model list is stored as pointers, not as a std::vector,
+	// so that sorting lists of this struct is fast
+};
+	
+
 
 struct ShaderModelRendererInternals;
 
@@ -270,7 +288,15 @@ public:
 	virtual void Render(const RenderModifierPtr& modifier, const CShaderDefines& context, int cullGroup, int flags);
 
 private:
+	
+	typedef ProxyAllocator<SMRTechBucket, Allocators::DynamicArena> TechBucketsAllocator;
+	
+	void PrepareUniformBuffers(size_t maxInstancesPerDraw, int flags, 
+						const std::vector<SMRTechBucket, TechBucketsAllocator>& techBuckets,
+						const RenderModifierPtr& modifier);
+	
 	ShaderModelRendererInternals* m;
+	MultiDrawIndirectCommands m_MultiDrawIndirectCommands;
 };
 
 #endif // INCLUDED_MODELRENDERER
diff --git a/source/renderer/ModelVertexRenderer.h b/source/renderer/ModelVertexRenderer.h
index e3120ce..fa0c918 100644
--- a/source/renderer/ModelVertexRenderer.h
+++ b/source/renderer/ModelVertexRenderer.h
@@ -154,6 +154,16 @@ public:
 	 * succeed.
 	 */
 	virtual void RenderModel(const CShaderProgramPtr& shader, int streamflags, CModel* model, CModelRData* data) = 0;
+	
+	// TODO: check if it still makes sense to derive from a ModelVertexRenderer class if the way of interacting with the
+	// "ModelVertexRenderer" differs too much between the different specializations
+	virtual void ResetDrawID() { debug_warn("not implemented"); }
+	virtual void ResetCommands() { debug_warn("not implemented"); }
+	virtual void AddInstance() { debug_warn("not implemented"); }
+	virtual void SetRenderModelInstanced(const CShaderProgramPtr& shader, int UNUSED(streamflags), CModel* model, CModelRData* UNUSED(data)) {}
+	virtual void RenderModelsInstanced(u32 modelsCount) { debug_warn("not implemented"); }
+	virtual void PrepareModel(const CShaderProgramPtr& shader, CModel* model) { debug_warn("not implemented"); }
+	virtual void BindAndUpload() { debug_warn("not implemented"); }
 };
 
 
diff --git a/source/renderer/RenderModifiers.cpp b/source/renderer/RenderModifiers.cpp
index bd2f0c9..8db9a56 100644
--- a/source/renderer/RenderModifiers.cpp
+++ b/source/renderer/RenderModifiers.cpp
@@ -22,6 +22,7 @@
 #include "precompiled.h"
 
 #include "lib/ogl.h"
+#include "maths/Vector2D.h"
 #include "maths/Vector3D.h"
 #include "maths/Vector4D.h"
 #include "maths/Matrix3D.h"
@@ -33,6 +34,7 @@
 #include "graphics/LOSTexture.h"
 #include "graphics/Model.h"
 #include "graphics/TextureManager.h"
+#include "graphics/UniformBlockManager.h"
 
 #include "renderer/RenderModifiers.h"
 #include "renderer/Renderer.h"
@@ -71,45 +73,105 @@ ShaderRenderModifier::ShaderRenderModifier()
 {
 }
 
-void ShaderRenderModifier::BeginPass(const CShaderProgramPtr& shader)
-{
-	shader->Uniform(str_transform, g_Renderer.GetViewCamera().GetViewProjection());
-	shader->Uniform(str_cameraPos, g_Renderer.GetViewCamera().GetOrientation().GetTranslation());
 
-	if (GetShadowMap() && shader->GetTextureBinding(str_shadowTex).Active())
+void ShaderRenderModifier::SetFrameUniforms()
+{
+	UniformBlockManager& uniformBlockManager = g_Renderer.GetUniformBlockManager();
+	CStrIntern frameUBO("FrameUBO");
+	CStrIntern modelUBO("ModelUBO");
+	UniformBinding transformBinding = uniformBlockManager.GetBinding(frameUBO, str_transform, false);
+	UniformBinding cameraPosBinding = uniformBlockManager.GetBinding(frameUBO, str_cameraPos, false);
+	
+	uniformBlockManager.SetUniform<UniformBlockManager::NOT_INSTANCED>(transformBinding, g_Renderer.GetViewCamera().GetViewProjection());
+	uniformBlockManager.SetUniform<UniformBlockManager::NOT_INSTANCED>(cameraPosBinding, g_Renderer.GetViewCamera().GetOrientation().GetTranslation());
+	
+	//shader->Uniform(str_transform, g_Renderer.GetViewCamera().GetViewProjection());
+	//shader->Uniform(str_cameraPos, g_Renderer.GetViewCamera().GetOrientation().GetTranslation());
+	
+	if (GetShadowMap())
 	{
-		shader->BindTexture(str_shadowTex, GetShadowMap()->GetTexture());
-		shader->Uniform(str_shadowTransform, GetShadowMap()->GetTextureMatrix());
+		UniformBinding shadowTransformBinding = uniformBlockManager.GetBinding(frameUBO, str_shadowTransform, false);
+		UniformBinding shadowScaleBinding = uniformBlockManager.GetBinding(frameUBO, str_shadowScale, false);
+
+		//shader->Uniform(str_shadowTransform, GetShadowMap()->GetTextureMatrix());
 		int width = GetShadowMap()->GetWidth();
 		int height = GetShadowMap()->GetHeight();
-		shader->Uniform(str_shadowScale, width, height, 1.0f / width, 1.0f / height); 
+		uniformBlockManager.SetUniform<UniformBlockManager::NOT_INSTANCED>(shadowScaleBinding, CVector4D(width, height, 1.0f / width, 1.0f / height));
+		uniformBlockManager.SetUniform<UniformBlockManager::NOT_INSTANCED>(shadowTransformBinding, GetShadowMap()->GetTextureMatrix());
+		//shader->Uniform(str_shadowScale, width, height, 1.0f / width, 1.0f / height);
 	}
-
+	
 	if (GetLightEnv())
 	{
-		shader->Uniform(str_ambient, GetLightEnv()->m_UnitsAmbientColor);
+		UniformBinding ambientBinding = uniformBlockManager.GetBinding(frameUBO, str_ambient, false);
+		UniformBinding sunDirBinding = uniformBlockManager.GetBinding(frameUBO, str_sunDir, false);
+		UniformBinding sunColorBinding = uniformBlockManager.GetBinding(frameUBO, str_sunColor, false);
+		
+		UniformBinding fogColorBinding = uniformBlockManager.GetBinding(frameUBO, str_fogColor, false);
+		UniformBinding fogParamsBinding = uniformBlockManager.GetBinding(frameUBO, str_fogParams, false);
+		
+		uniformBlockManager.SetUniform<UniformBlockManager::NOT_INSTANCED>(ambientBinding, GetLightEnv()->m_UnitsAmbientColor);
+		uniformBlockManager.SetUniform<UniformBlockManager::NOT_INSTANCED>(sunDirBinding, GetLightEnv()->GetSunDir());
+		uniformBlockManager.SetUniform<UniformBlockManager::NOT_INSTANCED>(sunColorBinding, GetLightEnv()->m_SunColor);
+		
+		uniformBlockManager.SetUniform<UniformBlockManager::NOT_INSTANCED>(fogColorBinding, GetLightEnv()->m_FogColor);
+		uniformBlockManager.SetUniform<UniformBlockManager::NOT_INSTANCED>(fogParamsBinding, CVector2D(GetLightEnv()->m_FogFactor, GetLightEnv()->m_FogMax));
+		/*shader->Uniform(str_ambient, GetLightEnv()->m_UnitsAmbientColor);
 		shader->Uniform(str_sunDir, GetLightEnv()->GetSunDir());
 		shader->Uniform(str_sunColor, GetLightEnv()->m_SunColor);
 		
 		shader->Uniform(str_fogColor, GetLightEnv()->m_FogColor);
-		shader->Uniform(str_fogParams, GetLightEnv()->m_FogFactor, GetLightEnv()->m_FogMax, 0.f, 0.f);
+		shader->Uniform(str_fogParams, GetLightEnv()->m_FogFactor, GetLightEnv()->m_FogMax, 0.f, 0.f);*/
+	}
+	
+	//if (shader->GetTextureBinding(str_losTex).Active())
+	//{
+	UniformBinding losTransformBinding = uniformBlockManager.GetBinding(frameUBO, str_losTransform, false);
+	CLOSTexture& los = g_Renderer.GetScene().GetLOSTexture();
+	// Don't bother sending the whole matrix, we just need two floats (scale and translation)
+	uniformBlockManager.SetUniform<UniformBlockManager::NOT_INSTANCED>(losTransformBinding, CVector2D(los.GetTextureMatrix()[0], los.GetTextureMatrix()[12]));
+	//shader->Uniform(str_losTransform, los.GetTextureMatrix()[0], los.GetTextureMatrix()[12], 0.f, 0.f);
+		
+	//}
+
+	// TODO: Bindings should probably be used differently now (with uniform blocks)
+	m_BindingInstancingTransform = uniformBlockManager.GetBinding(modelUBO, str_instancingTransform_0, true);
+	m_BindingModelID = uniformBlockManager.GetBinding(modelUBO, str_modelId_0, true);
+	/*
+	m_BindingInstancingTransform = shader->GetUniformBinding(str_instancingTransform);
+	m_BindingShadingColor = shader->GetUniformBinding(str_shadingColor);
+	m_BindingPlayerColor = shader->GetUniformBinding(str_playerColor);
+	*/
+}
+
+void ShaderRenderModifier::BeginPass(const CShaderProgramPtr& shader)
+{
+	if (GetShadowMap() && shader->GetTextureBinding(str_shadowTex).Active())
+	{
+		shader->BindTexture(str_shadowTex, GetShadowMap()->GetTexture());
 	}
 
 	if (shader->GetTextureBinding(str_losTex).Active())
 	{
 		CLOSTexture& los = g_Renderer.GetScene().GetLOSTexture();
 		shader->BindTexture(str_losTex, los.GetTextureSmooth());
-		// Don't bother sending the whole matrix, we just need two floats (scale and translation)
-		shader->Uniform(str_losTransform, los.GetTextureMatrix()[0], los.GetTextureMatrix()[12], 0.f, 0.f);
 	}
+}
 
-	m_BindingInstancingTransform = shader->GetUniformBinding(str_instancingTransform);
-	m_BindingShadingColor = shader->GetUniformBinding(str_shadingColor);
-	m_BindingPlayerColor = shader->GetUniformBinding(str_playerColor);
+
+void ShaderRenderModifier::SetModelUniforms(CModel* model)
+{
+	UniformBlockManager& uniformBlockManager = g_Renderer.GetUniformBlockManager();
+	if (m_BindingInstancingTransform.Active())
+		uniformBlockManager.SetUniform<UniformBlockManager::MODEL_INSTANCED>(m_BindingInstancingTransform, model->GetTransform());
+
+	if (m_BindingModelID.Active())
+		uniformBlockManager.SetUniform<UniformBlockManager::MODEL_INSTANCED>(m_BindingModelID, (GLuint)model->GetID());
 }
 
 void ShaderRenderModifier::PrepareModel(const CShaderProgramPtr& shader, CModel* model)
 {
+	/*
 	if (m_BindingInstancingTransform.Active())
 		shader->Uniform(m_BindingInstancingTransform, model->GetTransform());
 
@@ -118,4 +180,5 @@ void ShaderRenderModifier::PrepareModel(const CShaderProgramPtr& shader, CModel*
 
 	if (m_BindingPlayerColor.Active())
 		shader->Uniform(m_BindingPlayerColor, g_Game->GetPlayerColor(model->GetPlayerID()));
+	*/
 }
diff --git a/source/renderer/RenderModifiers.h b/source/renderer/RenderModifiers.h
index 802afd1..24af32a 100644
--- a/source/renderer/RenderModifiers.h
+++ b/source/renderer/RenderModifiers.h
@@ -50,6 +50,11 @@ class RenderModifier
 public:
 	RenderModifier() { }
 	virtual ~RenderModifier() { }
+	
+	/**
+	 * Sets values for uniforms that can be set once per frame and are the same for all objects
+	 */ 
+	virtual void SetFrameUniforms() { debug_warn("not implemented"); };
 
 	/**
 	 * BeginPass: Setup OpenGL for the given rendering pass.
@@ -72,6 +77,8 @@ public:
 	 * @param model The model that is about to be rendered.
 	 */
 	virtual void PrepareModel(const CShaderProgramPtr& shader, CModel* model) = 0;
+	
+	virtual void SetModelUniforms(CModel* model) = 0;
 };
 
 
@@ -96,6 +103,8 @@ public:
 	 * @param shadow the shadow map
 	 */
 	void SetShadowMap(const ShadowMap* shadow);
+	
+	virtual void SetModelUniforms(CModel* model) { debug_warn("not implemented!"); }
 
 	/**
 	 * SetLightEnv: Set the light environment that will be used for rendering.
@@ -122,13 +131,15 @@ public:
 	ShaderRenderModifier();
 
 	// Implementation
+	void SetFrameUniforms();
+	void SetModelUniforms(CModel* model);
 	void BeginPass(const CShaderProgramPtr& shader);
 	void PrepareModel(const CShaderProgramPtr& shader, CModel* model);
 
 private:
-	CShaderProgram::Binding m_BindingInstancingTransform;
-	CShaderProgram::Binding m_BindingShadingColor;
-	CShaderProgram::Binding m_BindingPlayerColor;
+	UniformBinding m_BindingInstancingTransform;
+	UniformBinding m_BindingShadingColor;
+	UniformBinding m_BindingModelID;
 };
 
 #endif // INCLUDED_RENDERMODIFIERS
diff --git a/source/renderer/Renderer.cpp b/source/renderer/Renderer.cpp
index aa99603..95fdcbc 100644
--- a/source/renderer/Renderer.cpp
+++ b/source/renderer/Renderer.cpp
@@ -58,6 +58,7 @@
 #include "graphics/Terrain.h"
 #include "graphics/Texture.h"
 #include "graphics/TextureManager.h"
+#include "graphics/UniformBlockManager.h"
 #include "renderer/HWLightingModelRenderer.h"
 #include "renderer/InstancingModelRenderer.h"
 #include "renderer/ModelRenderer.h"
@@ -265,6 +266,8 @@ public:
 
 	/// Shader manager
 	CShaderManager shaderManager;
+	
+	UniformBlockManager uniformBlockManager;
 
 	/// Water manager
 	WaterManager waterManager;
@@ -414,7 +417,8 @@ CRenderer::CRenderer()
 {
 	m = new CRendererInternals;
 	m_WaterManager = &m->waterManager;
-	m_SkyManager = &m->skyManager;
+	m_SkyManager = &m->skyManager;	
+	m_UniformBlockManager = &m->uniformBlockManager;
 
 	g_ProfileViewer.AddRootTable(&m->profileTable);
 
@@ -649,6 +653,8 @@ bool CRenderer::Open(int width, int height)
 	// the shader path have been determined.
 	m->overlayRenderer.Initialize();
 	
+	m->uniformBlockManager.Initialize();
+	
 	if (m_Options.m_Postproc)
 		m->postprocManager.Initialize();
 
diff --git a/source/renderer/Renderer.h b/source/renderer/Renderer.h
index 044bc95..ea2b704 100644
--- a/source/renderer/Renderer.h
+++ b/source/renderer/Renderer.h
@@ -32,6 +32,7 @@
 
 #include "graphics/ShaderDefines.h"
 #include "renderer/Scene.h"
+//#include "graphics/UniformBlockManager.h"
 
 // necessary declarations
 class CFontManager;
@@ -51,6 +52,7 @@ class ScriptInterface;
 class SkyManager;
 class TerrainRenderer;
 class WaterManager;
+class UniformBlockManager;
 
 // rendering modes
 enum ERenderMode { WIREFRAME, SOLID, EDGED_FACES };
@@ -291,6 +293,8 @@ public:
 	// return the current cull camera
 	const CCamera& GetCullCamera() const { return m_CullCamera; }
 
+	UniformBlockManager& GetUniformBlockManager() { return *m_UniformBlockManager; }
+
 	/**
 	 * GetWaterManager: Return the renderer's water manager.
 	 *
@@ -447,6 +451,8 @@ protected:
 	void EnumCaps();
 	// per-frame renderer stats
 	Stats m_Stats;
+	
+	UniformBlockManager* m_UniformBlockManager;
 
 	/**
 	 * m_WaterManager: the WaterManager object used for water textures and settings
diff --git a/source/renderer/VertexArray.cpp b/source/renderer/VertexArray.cpp
index 8128e41..aca24ae 100644
--- a/source/renderer/VertexArray.cpp
+++ b/source/renderer/VertexArray.cpp
@@ -309,6 +309,17 @@ u8* VertexArray::Bind()
 	return base;
 }
 
+// Bind this array, returns the base address for calls to glVertexPointer etc.
+u8* VertexArray::GetBindAddress()
+{
+	if (!m_VB)
+		return NULL;
+
+	u8* base = m_VB->m_Owner->GetBindAddress();
+	base += m_VB->m_Index*m_Stride;
+	return base;
+}
+
 
 // Free the backing store to save some memory
 void VertexArray::FreeBackingStore()
diff --git a/source/renderer/VertexArray.h b/source/renderer/VertexArray.h
index be31362..ceafa58 100644
--- a/source/renderer/VertexArray.h
+++ b/source/renderer/VertexArray.h
@@ -180,6 +180,10 @@ public:
 	void PrepareForRendering();
 	// Bind this array, returns the base address for calls to glVertexPointer etc.
 	u8* Bind();
+	
+	u8* GetBindAddress();
+	
+	u8* GetInstancingDataBasePtr() { return m_VB->m_Owner->GetInstancingDataBasePtr(); }
 
 	// If you know for certain that you'll never have to change the data again,
 	// call this to free some memory.
diff --git a/source/renderer/VertexBuffer.cpp b/source/renderer/VertexBuffer.cpp
index b670952..1882973 100644
--- a/source/renderer/VertexBuffer.cpp
+++ b/source/renderer/VertexBuffer.cpp
@@ -28,23 +28,28 @@
 #include "VertexBufferManager.h"
 #include "ps/CLogger.h"
 
+#define MAX_INSTANCING_DRAWIDS	2000
+
 // Absolute maximum (bytewise) size of each GL vertex buffer object.
 // Make it large enough for the maximum feasible mesh size (64K vertexes,
 // 64 bytes per vertex in InstancingModelRenderer).
+// Add 2048 because we need 2000 bytes for the instancing data in each VBO (and 
 // TODO: measure what influence this has on performance
-#define MAX_VB_SIZE_BYTES		(4*1024*1024)
+#define MAX_VB_SIZE_BYTES		(4*1024*1024+MAX_INSTANCING_DRAWIDS*4);
 
 CVertexBuffer::CVertexBuffer(size_t vertexSize, GLenum usage, GLenum target)
-	: m_VertexSize(vertexSize), m_Handle(0), m_SysMem(0), m_Usage(usage), m_Target(target)
+	: m_VertexSize(vertexSize), m_Handle(0), m_SysMem(0), m_Usage(usage), m_Target(target), m_InstancingDataOffset(0)
 {
+	// TODO: Handling of the max size is a bit strange now
 	size_t size = MAX_VB_SIZE_BYTES;
 
 	if (target == GL_ARRAY_BUFFER) // vertex data buffer
 	{
+		m_InstancingDataOffset = MAX_INSTANCING_DRAWIDS * sizeof(GLuint);
 		// We want to store 16-bit indices to any vertex in a buffer, so the
 		// buffer must never be bigger than vertexSize*64K bytes since we can 
 		// address at most 64K of them with 16-bit indices
-		size = std::min(size, vertexSize*65536);
+		size = std::min(size, vertexSize * 65536 + m_InstancingDataOffset);
 	}
 
 	// store max/free vertex counts
@@ -55,7 +60,27 @@ CVertexBuffer::CVertexBuffer(size_t vertexSize, GLenum usage, GLenum target)
 	{
 		pglGenBuffersARB(1, &m_Handle);
 		pglBindBufferARB(m_Target, m_Handle);
-		pglBufferDataARB(m_Target, m_MaxVertices * m_VertexSize, 0, m_Usage);
+		
+		// HACK: This is a hacky workaround because GL_ARB_shader_draw_parameters isn't widely supported by drivers.
+		// We just add numbers from 0 to MAX_INSTANCING_DRAWIDS to *each* VertexBuffer. This allows us to use these
+		// numbers as indices and can be used to index into uniform buffers from the shader (to get the data that 
+		// belongs to the objects we currently are drawing)
+		if (target == GL_ARRAY_BUFFER)
+		{
+			m_MaxVertices = m_FreeVertices = (size - m_InstancingDataOffset) / vertexSize;
+			pglBufferDataARB(m_Target, m_InstancingDataOffset + m_MaxVertices * m_VertexSize, 0, m_Usage);
+			
+			std::vector<GLuint> drawIDs(MAX_INSTANCING_DRAWIDS);
+			for (int i=0; i<MAX_INSTANCING_DRAWIDS; ++i)
+				drawIDs[i] = i;
+			pglBufferSubDataARB(GL_ARRAY_BUFFER, 0, m_InstancingDataOffset, &drawIDs[0]);
+		}
+		else
+		{
+			pglBufferDataARB(m_Target, m_MaxVertices * m_VertexSize, 0, m_Usage);
+		}
+		
+		
 		pglBindBufferARB(m_Target, 0);
 	}
 	else
@@ -211,7 +236,17 @@ void CVertexBuffer::UpdateChunkVertices(VBChunk* chunk, void* data)
 		else
 		{
 			pglBindBufferARB(m_Target, m_Handle);
-			pglBufferSubDataARB(m_Target, chunk->m_Index * m_VertexSize, chunk->m_Count * m_VertexSize, data);
+			pglBufferSubDataARB(m_Target, m_InstancingDataOffset + chunk->m_Index * m_VertexSize, chunk->m_Count * m_VertexSize, data);
+			/*
+			// TODO: That's a hack...
+			if (m_Target == GL_ARRAY_BUFFER)
+			{
+				// re-create the instancing data
+				std::vector<GLuint> drawIDs(MAX_INSTANCING_DRAWIDS);
+				for (int i=0; i<MAX_INSTANCING_DRAWIDS; ++i)
+					drawIDs[i] = i;
+				pglBufferSubDataARB(GL_ARRAY_BUFFER, 0, m_InstancingDataOffset, &drawIDs[0]);
+			}*/
 			pglBindBufferARB(m_Target, 0);
 		}
 	}
@@ -249,7 +284,18 @@ u8* CVertexBuffer::Bind()
 		if (needUpload)
 		{
 			// Tell the driver that it can reallocate the whole VBO
-			pglBufferDataARB(m_Target, m_MaxVertices * m_VertexSize, NULL, m_Usage);
+			pglBufferDataARB(m_Target, m_InstancingDataOffset + m_MaxVertices * m_VertexSize, NULL, m_Usage);
+
+			// HACK:
+			// TODO: Which models use streaming?
+			if (m_Target == GL_ARRAY_BUFFER)
+			{
+				// re-create the instancing data
+				std::vector<GLuint> drawIDs(MAX_INSTANCING_DRAWIDS);
+				for (int i=0; i<MAX_INSTANCING_DRAWIDS; ++i)
+					drawIDs[i] = i;
+				pglBufferSubDataARB(GL_ARRAY_BUFFER, 0, m_InstancingDataOffset, &drawIDs[0]);
+			}
 
 			// (In theory, glMapBufferRange with GL_MAP_INVALIDATE_BUFFER_BIT could be used
 			// here instead of glBufferData(..., NULL, ...) plus glMapBuffer(), but with
@@ -265,6 +311,9 @@ u8* CVertexBuffer::Bind()
 					LOGERROR("glMapBuffer failed");
 					break;
 				}
+				
+				// Modify per-vertex data and skip static instancing data
+				p = (void*)((u8*)p + m_InstancingDataOffset);
 
 #ifndef NDEBUG
 				// To help detect bugs where PrepareForRendering() was not called,
@@ -305,13 +354,13 @@ u8* CVertexBuffer::Bind()
 			chunk->m_Needed = false;
 	}
 
-	return (u8*)0;
+	return (u8*)m_InstancingDataOffset;
 }
 
 u8* CVertexBuffer::GetBindAddress()
 {
 	if (g_Renderer.m_Caps.m_VBO)
-		return (u8*)0;
+		return (u8*)m_InstancingDataOffset;
 	else
 		return m_SysMem;
 }
@@ -330,6 +379,7 @@ size_t CVertexBuffer::GetBytesReserved() const
 	return MAX_VB_SIZE_BYTES;
 }
 
+// TODO: The size for instancing data should probably be added
 size_t CVertexBuffer::GetBytesAllocated() const
 {
 	return (m_MaxVertices - m_FreeVertices) * m_VertexSize;
diff --git a/source/renderer/VertexBuffer.h b/source/renderer/VertexBuffer.h
index 12c2cf7..0fc6fe9 100644
--- a/source/renderer/VertexBuffer.h
+++ b/source/renderer/VertexBuffer.h
@@ -97,6 +97,8 @@ public:
 
 	/// Get the address that Bind() will return, without actually binding
 	u8* GetBindAddress();
+	
+	u8* GetInstancingDataBasePtr() { return 0; }
 
 	/// Unbind any currently-bound buffer, so glVertexPointer etc calls will not attempt to use it
 	static void Unbind();
@@ -158,6 +160,9 @@ private:
 	GLenum m_Usage;
 	/// Buffer target (GL_ARRAY_BUFFER, GL_ELEMENT_ARRAY_BUFFER)
 	GLenum m_Target;
+	
+	/// Pointing after the instancing data, i.e. where the per-vertex data starts
+	size_t m_InstancingDataOffset;
 };
 
 #endif
