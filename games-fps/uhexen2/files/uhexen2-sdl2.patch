diff --git a/engine/h2shared/gl_vidsdl.c b/engine/h2shared/gl_vidsdl.c
index ae29dd0b..c71737fb 100644
--- a/engine/h2shared/gl_vidsdl.c
+++ b/engine/h2shared/gl_vidsdl.c
@@ -116,8 +116,13 @@ typedef struct {
 } attributes_t;
 static attributes_t	vid_attribs;
 
+#if SDLQUAKE == 2
+SDL_Window	*window;
+static SDL_GLContext glcontext;
+#else
 static const SDL_VideoInfo	*vid_info;
 static SDL_Surface	*screen;
+#endif
 static qboolean	vid_menu_fs;
 static qboolean	fs_toggle_works = true;
 
@@ -277,12 +282,20 @@ void VID_HandlePause (qboolean paused)
 
 qboolean VID_HasMouseOrInputFocus (void)
 {
+#if SDLQUAKE == 2
+	return (SDL_GetWindowFlags(window) & (SDL_WINDOW_MOUSE_FOCUS | SDL_WINDOW_INPUT_FOCUS)) != 0;
+#else
 	return (SDL_GetAppState() & (SDL_APPMOUSEFOCUS | SDL_APPINPUTFOCUS)) != 0;
+#endif
 }
 
 qboolean VID_IsMinimized (void)
 {
+#if SDLQUAKE == 2
+	return !(SDL_GetWindowFlags(window) & SDL_WINDOW_SHOWN);
+#else
 	return !(SDL_GetAppState() & SDL_APPACTIVE);
+#endif
 }
 
 
@@ -307,16 +320,30 @@ static void VID_SetIcon (void)
 	if (icon == NULL)
 		return;
 
+#if SDLQUAKE == 2
+	SDL_SetColorKey(icon, SDL_TRUE, 0);
+#else
 	SDL_SetColorKey(icon, SDL_SRCCOLORKEY, 0);
+#endif
+	
 
 	color.r = 255;
 	color.g = 255;
 	color.b = 255;
-	SDL_SetColors(icon, &color, 0, 1);	/* just in case */
+	/* just in case */
+#if SDLQUAKE == 2
+	SDL_SetPaletteColors(icon->format->palette, &color, 0, 1);
+#else
+	SDL_SetColors(icon, &color, 0, 1);	
+#endif
 	color.r = 192;
 	color.g = 0;
 	color.b = 0;
+#if SDLQUAKE == 2
+	SDL_SetPaletteColors(icon->format->palette, &color, 1, 1);
+#else
 	SDL_SetColors(icon, &color, 1, 1);
+#endif
 
 	ptr = (Uint8 *)icon->pixels;
 	/* one bit represents a pixel, black or white:  each
@@ -330,8 +357,13 @@ static void VID_SetIcon (void)
 		}
 	}
 
+#if SDLQUAKE == 2
+	SDL_SetWindowIcon(window, icon);
+#else
 	SDL_WM_SetIcon(icon, NULL);
+#endif
 	SDL_FreeSurface(icon);
+
 #endif /* !OSX */
 }
 
@@ -413,14 +445,14 @@ static qboolean VID_SetMode (int modenum)
 {
 	Uint32	flags;
 	int	i, is_fullscreen;
+#if SDLQUAKE == 2
+	int display_index;
+	SDL_DisplayMode desktop_mode;
+	int screen_w, screen_h;
+#endif
 
 	in_mode_set = true;
 
-	//flags = (SDL_OPENGL|SDL_NOFRAME);
-	flags = (SDL_OPENGL);
-	if (vid_config_fscr.integer)
-		flags |= SDL_FULLSCREEN;
-
 	// setup the attributes
 	if (bpp >= 32)
 	{
@@ -453,6 +485,69 @@ static qboolean VID_SetMode (int modenum)
 
 	Con_SafePrintf ("Requested mode %d: %dx%dx%d\n", modenum, modelist[modenum].width, modelist[modenum].height, bpp);
 
+#if SDLQUAKE == 2
+	// Create the window without the fullscreen flag first so we can query its display and check the desktop resolution
+	window = SDL_CreateWindow("", SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED, modelist[modenum].width, modelist[modenum].height, SDL_WINDOW_OPENGL);
+
+	// Start with empty flags until we determine the fullscreen mode
+	flags = 0;
+	if (vid_config_fscr.integer)
+	{
+		flags = SDL_WINDOW_FULLSCREEN;
+
+		// Try to check the desktop resolution. If it matches the window size, use a borderless window
+		display_index = SDL_GetWindowDisplayIndex(window);
+		if (display_index >= 0 && SDL_GetDesktopDisplayMode(display_index, &desktop_mode) == 0)
+		{
+			SDL_GetWindowSize(window, &screen_w, &screen_h);
+			if (screen_w == desktop_mode.w && screen_h == desktop_mode.h)
+			{
+				flags = SDL_WINDOW_FULLSCREEN_DESKTOP;
+				Con_Printf ("Fullscreen res matches desktop; using borderless window\n");
+			}
+		}
+		else
+			Con_Printf ("Failed to query desktop display mode; using native fullscreen\n");
+	}
+
+	if (!window)
+	{
+		if (!multisample)
+			Sys_Error ("Couldn't set video mode: %s", SDL_GetError());
+		else
+		{
+			Con_SafePrintf ("multisample window failed\n");
+			multisample = 0;
+			SDL_GL_SetAttribute(SDL_GL_MULTISAMPLEBUFFERS, 0);
+			SDL_GL_SetAttribute(SDL_GL_MULTISAMPLESAMPLES, multisample);
+			// Add OpenGL flag back in
+			flags |= SDL_WINDOW_OPENGL;
+			window = SDL_CreateWindow("", SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED, modelist[modenum].width, modelist[modenum].height, flags);
+			if (!window)
+				Sys_Error ("Couldn't set video mode: %s", SDL_GetError());
+		}
+	} else
+		// Now that we have the fullscreen flags, set them
+		SDL_SetWindowFullscreen(window, flags);
+
+	glcontext = SDL_GL_CreateContext(window);
+	if (!glcontext)
+	{
+		SDL_DestroyWindow(window);
+		window = NULL;
+		Sys_Error ("Couldn't create gl context: %s", SDL_GetError());
+	}
+
+	VID_SetIcon();
+	SDL_SetWindowTitle(window, WM_TITLEBAR_TEXT);
+
+	is_fullscreen = (SDL_GetWindowFlags(window) & (SDL_WINDOW_FULLSCREEN | SDL_WINDOW_FULLSCREEN_DESKTOP)) ? 1 : 0;
+#else
+	//flags = (SDL_OPENGL|SDL_NOFRAME);
+	flags = (SDL_OPENGL);
+	if (vid_config_fscr.integer)
+		flags |= SDL_FULLSCREEN;
+
 	VID_SetIcon();
 
 	screen = SDL_SetVideoMode (modelist[modenum].width, modelist[modenum].height, bpp, flags);
@@ -474,9 +569,13 @@ static qboolean VID_SetMode (int modenum)
 		}
 	}
 
+	is_fullscreen = (screen->flags & SDL_FULLSCREEN) ? 1 : 0;
+
+	SDL_WM_SetCaption(WM_TITLEBAR_TEXT, WM_INTF_TEXT);
+#endif
+
 	// set vid_modenum properly and adjust other vars
 	vid_modenum = modenum;
-	is_fullscreen = (screen->flags & SDL_FULLSCREEN) ? 1 : 0;
 	modestate = (is_fullscreen) ? MS_FULLDIB : MS_WINDOWED;
 	Cvar_SetValueQuick (&vid_config_glx, modelist[vid_modenum].width);
 	Cvar_SetValueQuick (&vid_config_gly, modelist[vid_modenum].height);
@@ -496,8 +595,6 @@ static qboolean VID_SetMode (int modenum)
 	}
 	Cvar_SetValueQuick (&vid_config_fsaa, multisample);
 
-	SDL_WM_SetCaption(WM_TITLEBAR_TEXT, WM_ICON_TEXT);
-
 	IN_HideMouse ();
 
 	in_mode_set = false;
@@ -670,12 +767,14 @@ static void VID_InitGamma (void)
 		fx_gamma = VID_Check3dfxGamma();
 	if (!fx_gamma)
 	{
+#if SDLQUAKE < 2
 #if USE_GAMMA_RAMPS
 		gammaworks	= (SDL_GetGammaRamp(orig_ramps[0], orig_ramps[1], orig_ramps[2]) == 0);
 		if (gammaworks)
 		    gammaworks	= (SDL_SetGammaRamp(orig_ramps[0], orig_ramps[1], orig_ramps[2]) == 0);
 #else
 		gammaworks	= (SDL_SetGamma(1, 1, 1) == 0);
+#endif
 #endif
 	}
 
@@ -691,11 +790,13 @@ static void VID_ShutdownGamma (void)
 /*	if (fx_gamma) do3dfxGammaCtrl(1);*/
 #endif
 	Shutdown_3dfxGamma();
+#if SDLQUAKE < 2
 #if USE_GAMMA_RAMPS	/* restore hw-gamma */
 	if (gammaworks) SDL_SetGammaRamp(orig_ramps[0], orig_ramps[1], orig_ramps[2]);
 #else
 	if (gammaworks) SDL_SetGamma (1,1,1);
 #endif
+#endif
 }
 
 static void VID_SetGamma (void)
@@ -709,11 +810,13 @@ static void VID_SetGamma (void)
 #else
 	if (fx_gamma) do3dfxGammaCtrl(value);
 #endif
+#if SDLQUAKE < 2
 #if USE_GAMMA_RAMPS
 	if (gammaworks) SDL_SetGammaRamp(ramps[0], ramps[1], ramps[2]);
 #else
 	if (gammaworks) SDL_SetGamma(value,value,value);
 #endif
+#endif
 }
 
 void VID_ShiftPalette (const unsigned char *palette)
@@ -1040,7 +1143,12 @@ void GL_BeginRendering (int *x, int *y, int *width, int *height)
 void GL_EndRendering (void)
 {
 	if (!scr_skipupdate)
+#if SDLQUAKE == 2
+		SDL_GL_SwapWindow(window);
+#else
 		SDL_GL_SwapBuffers();
+#endif
+
 
 // handle the mouse state when windowed if that's changed
 	if (_enable_mouse.integer != enable_mouse /*&& modestate == MS_WINDOWED*/)
@@ -1254,7 +1362,7 @@ static void VID_ChangeVideoMode (int newmode)
 {
 	int	temp;
 
-	if (!screen)
+	if (!window)
 		return;
 
 	temp = scr_disabled_for_loading;
@@ -1281,7 +1389,12 @@ static void VID_ChangeVideoMode (int newmode)
 	IN_ShowMouse ();
 
 	// Kill device and rendering contexts
+#if SDLQUAKE == 2
+	SDL_GL_DeleteContext(glcontext);
+	SDL_DestroyWindow(window);
+#else
 	SDL_FreeSurface(screen);
+#endif
 	SDL_QuitSubSystem(SDL_INIT_VIDEO);	// also unloads the opengl driver
 
 	// re-init sdl_video, set the mode and re-init opengl
@@ -1293,7 +1406,9 @@ static void VID_ChangeVideoMode (int newmode)
 #endif
 	VID_SetMode (newmode);
 	// re-get the video info since we re-inited sdl_video
+#if SDLQUAKE < 2
 	vid_info = SDL_GetVideoInfo();
+#endif
 
 	// Reload graphics wad file (Draw_PicFromWad writes glpic_t data (sizes,
 	// texnums) right on top of the original pic data, so the pic data will
@@ -1364,10 +1479,68 @@ static int sort_modes (const void *arg1, const void *arg2)
 	return a1->width - a2->width;
 }
 
-static void VID_PrepareModes (SDL_Rect **sdl_modes)
+static void VID_PrepareModes (void)
 {
 	int	i, j;
 	qboolean	not_multiple;
+	SDL_Rect	**sdl_modes;
+#if SDLQUAKE == 2
+	int k;
+	SDL_DisplayMode	mode;
+	SDL_Rect	mode_rects[MAX_MODE_LIST];
+	SDL_Rect	*ptr_array[MAX_MODE_LIST + 1];
+#endif
+
+#if SDLQUAKE == 2
+	// SDL2 does not have a function to get the full modelist, so we must build it manually.
+
+	num_fmodes = 0;
+
+	// Fill the list with all modes supported by the first display.
+	for (i = 0; i < SDL_GetNumDisplayModes(0) && i < MAX_MODE_LIST; i++)
+	{
+		SDL_GetDisplayMode(0, i, &mode);
+		mode_rects[num_fmodes].x = 0;
+		mode_rects[num_fmodes].y = 0;
+		mode_rects[num_fmodes].w = mode.w;
+		mode_rects[num_fmodes].h = mode.h;
+		num_fmodes++;
+	}
+
+	// Check the other displays and add any modes that aren't already in the list
+	for (i = 1; i < SDL_GetNumVideoDisplays(); i++)
+		for (j = 0; j < SDL_GetNumDisplayModes(i) && num_fmodes < MAX_MODE_LIST; j++)
+		{
+			SDL_GetDisplayMode(i, j, &mode);
+			mode_rects[num_fmodes].x = 0;
+			mode_rects[num_fmodes].y = 0;
+			mode_rects[num_fmodes].w = mode.w;
+			mode_rects[num_fmodes].h = mode.h;
+			num_fmodes++;
+
+			for (k = 0; k < num_fmodes; k++)
+			{
+				if (mode.w == mode_rects[k].w && mode.h == mode_rects[k].h)
+				{
+					num_fmodes--;
+					break;
+				}
+			}
+		}
+
+	if (num_fmodes > 0)
+	{
+		for (i = 0; i < num_fmodes; i++)
+			ptr_array[i] = &mode_rects[i];
+		ptr_array[num_fmodes] = NULL;
+		sdl_modes = ptr_array;
+	}
+	else
+		sdl_modes = NULL;
+#else
+	// retrieve the list of fullscreen modes
+	sdl_modes = SDL_ListModes(NULL, SDL_OPENGL|SDL_FULLSCREEN);
+#endif
 
 	num_fmodes = 0;
 	num_wmodes = 0;
@@ -1554,7 +1727,6 @@ void	VID_Init (const unsigned char *palette)
 	static char fxglide_env_nosplash[32] = "FX_GLIDE_NO_SPLASH=1";
 #endif
 	int	i, temp, width, height;
-	SDL_Rect	**enumlist;
 	const SDL_version	*sdl_version;
 	const char	*read_vars[] = {
 				"vid_config_fscr",
@@ -1591,9 +1763,13 @@ void	VID_Init (const unsigned char *palette)
 	vid.numpages = 2;
 
 	// see if the SDL version we linked to is multisampling-capable
+#if SDLQUAKE == 2
+	sdl_has_multisample = true;
+#else
 	sdl_version = SDL_Linked_Version();
 	if (SDL_VERSIONNUM(sdl_version->major,sdl_version->minor,sdl_version->patch) >= SDL_VER_WITH_MULTISAMPLING)
 		sdl_has_multisample = true;
+#endif
 
 #ifndef __MORPHOS__
 	// enable vsync for nvidia geforce or newer - S.A
@@ -1636,10 +1812,9 @@ void	VID_Init (const unsigned char *palette)
 
 	// this will contain the "best bpp" for the current display
 	// make sure to re-retrieve it if you ever re-init sdl_video
+#if SDLQUAKE < 2
 	vid_info = SDL_GetVideoInfo();
-
-	// retrieve the list of fullscreen modes
-	enumlist = SDL_ListModes(NULL, SDL_OPENGL|SDL_FULLSCREEN);
+#endif
 
 	i = COM_CheckParm("-bpp");
 	if (i && i < com_argc-1)
@@ -1648,7 +1823,7 @@ void	VID_Init (const unsigned char *palette)
 	}
 
 	// prepare the modelists, find the actual modenum for vid_default
-	VID_PrepareModes(enumlist);
+	VID_PrepareModes();
 
 	// set vid_mode to our safe default first
 	Cvar_SetValueQuick (&vid_mode, vid_default);
@@ -1784,6 +1959,14 @@ void	VID_Init (const unsigned char *palette)
 void	VID_Shutdown (void)
 {
 	VID_ShutdownGamma();
+
+#if SDLQUAKE == 2
+	if (glcontext)
+		SDL_GL_DeleteContext(glcontext);
+	if (window)
+		SDL_DestroyWindow(window);
+#endif
+
 	SDL_QuitSubSystem(SDL_INIT_VIDEO);
 }
 
@@ -1799,21 +1982,63 @@ extern qboolean menu_disabled_mouse;
 void VID_ToggleFullscreen (void)
 {
 	int	is_fullscreen;
+#if SDLQUAKE == 2
+	int display_index;
+	SDL_DisplayMode desktop_mode;
+	int screen_w, screen_h;
+	int fullscreen_flag;
+#endif
 
 	if (!fs_toggle_works)
 		return;
 	if (!num_fmodes)
 		return;
+#if SDLQUAKE == 2
+	if (!window)
+#else
 	if (!screen)
+#endif
 		return;
 
 	S_ClearBuffer ();
 
+#if SDLQUAKE == 2
+	is_fullscreen = SDL_GetWindowFlags(window) & (SDL_WINDOW_FULLSCREEN | SDL_WINDOW_FULLSCREEN_DESKTOP);
+
+	// If we're switching to fullscreen, check to see if our window has the same size as the desktop.
+	// If it does, use a borderless window instead of "real" fullscreen for better wm integration.
+	if (!is_fullscreen)
+	{
+		fullscreen_flag = SDL_WINDOW_FULLSCREEN;
+
+		display_index = SDL_GetWindowDisplayIndex(window);
+		if (display_index >= 0 && SDL_GetDesktopDisplayMode(display_index, &desktop_mode) == 0)
+		{
+			SDL_GetWindowSize(window, &screen_w, &screen_h);
+			if (screen_w == desktop_mode.w && screen_h == desktop_mode.h)
+			{
+				fullscreen_flag = SDL_WINDOW_FULLSCREEN_DESKTOP;
+				Con_Printf ("Fullscreen res matches desktop; using borderless window\n");
+			}
+		}
+		else
+			Con_Printf ("Failed to query desktop display mode; using native fullscreen\n");
+	}
+	else
+		fullscreen_flag = 0;
+
+	if (SDL_SetWindowFullscreen(window, fullscreen_flag) == 0)
+#else
 	// This doesn't seem to cause any trouble even
 	// with is_3dfx == true and FX_GLX_MESA == f
 	if (SDL_WM_ToggleFullScreen(screen) == 1)
+#endif
 	{
+#if SDLQUAKE == 2
+		is_fullscreen = !is_fullscreen;
+#else
 		is_fullscreen = (screen->flags & SDL_FULLSCREEN) ? 1 : 0;
+#endif
 		Cvar_SetValueQuick(&vid_config_fscr, is_fullscreen);
 		modestate = (is_fullscreen) ? MS_FULLDIB : MS_WINDOWED;
 		if (is_fullscreen)
@@ -1837,7 +2062,11 @@ void VID_ToggleFullscreen (void)
 	else
 	{
 		fs_toggle_works = false;
+#if SDLQUAKE == 2
+		Con_Printf ("SDL_SetWindowFulscreen failed\n");
+#else
 		Con_Printf ("SDL_WM_ToggleFullScreen failed\n");
+#endif
 	}
 }
 
diff --git a/engine/h2shared/in_sdl.c b/engine/h2shared/in_sdl.c
index d5acd1cc..043d7925 100644
--- a/engine/h2shared/in_sdl.c
+++ b/engine/h2shared/in_sdl.c
@@ -27,6 +27,10 @@
 #include "quakedef.h"
 
 
+#if SDLQUAKE == 2
+extern SDL_Window *window;
+#endif
+
 static qboolean	prev_gamekey;
 
 /* mouse variables */
@@ -44,8 +48,10 @@ static int buttonremap[] =
 	K_MOUSE1,
 	K_MOUSE3,	/* right button		*/
 	K_MOUSE2,	/* middle button	*/
+#if SDLQUAKE == 1
 	K_MWHEELUP,
 	K_MWHEELDOWN,
+#endif
 	K_MOUSE4,
 	K_MOUSE5
 };
@@ -190,7 +196,11 @@ void IN_ActivateMouse (void)
 		{
 			mouseactivatetoggle = true;
 			mouseactive = true;
+#if SDLQUAKE == 2
+			SDL_SetRelativeMouseMode(SDL_TRUE);
+#else
 			SDL_WM_GrabInput (SDL_GRAB_ON);
+#endif
 		}
 	    }
 	}
@@ -215,7 +225,11 @@ void IN_DeactivateMouse (void)
 	    if (mouseactivatetoggle) {
 		mouseactivatetoggle = false;
 		mouseactive = false;
+#if SDLQUAKE == 2
+		SDL_SetRelativeMouseMode(SDL_FALSE);
+#else
 		SDL_WM_GrabInput (SDL_GRAB_OFF);
+#endif
 	    }
 	}
 
@@ -232,7 +246,11 @@ static void IN_StartupMouse (void)
 /*	IN_HideMouse ();*/
 	if (safemode || COM_CheckParm ("-nomouse"))
 	{
+#if SDLQUAKE == 2
+		SDL_SetRelativeMouseMode(SDL_FALSE);
+#else
 		SDL_WM_GrabInput (SDL_GRAB_OFF);
+#endif
 		return;
 	}
 
@@ -242,7 +260,11 @@ static void IN_StartupMouse (void)
 	{
 		mouseactivatetoggle = true;
 		mouseactive = true;
+#if SDLQUAKE == 2
+		SDL_SetRelativeMouseMode(SDL_TRUE);
+#else
 		SDL_WM_GrabInput (SDL_GRAB_ON);
+#endif
 		SDL_GetRelativeMouseState (NULL, NULL);
 	}
 }
@@ -298,8 +320,10 @@ void IN_Init (void)
 	IN_StartupJoystick ();
 
 	prev_gamekey = Key_IsGameKey();
+#if SDLQUAKE < 2
 	SDL_EnableUNICODE (!prev_gamekey);
 	SDL_EnableKeyRepeat (SDL_DEFAULT_REPEAT_DELAY, SDL_DEFAULT_REPEAT_INTERVAL*2);
+#endif
 }
 
 /*
@@ -331,8 +355,10 @@ void IN_ReInit (void)
 	IN_StartupMouse ();
 
 	prev_gamekey = Key_IsGameKey();
+#if SDLQUAKE < 2
 	SDL_EnableUNICODE (!prev_gamekey);
 	SDL_EnableKeyRepeat (SDL_DEFAULT_REPEAT_DELAY, SDL_DEFAULT_REPEAT_INTERVAL*2);
+#endif
 
 	/* no need for joystick to reinit */
 }
@@ -478,7 +504,11 @@ static void IN_StartupJoystick (void)
 	Con_Printf ("SDL_Joystick: %d devices are reported:\n", joy_available);
 	for (i = 0; i < joy_available; i++)
 	{
+#if SDLQUAKE == 2
+		Con_Printf("#%d: \"%s\"\n", i, SDL_JoystickNameForIndex(i));
+#else
 		Con_Printf("#%d: \"%s\"\n", i, SDL_JoystickName(i));
+#endif
 	}
 
 	trackballactive = true;
@@ -528,7 +558,11 @@ static void IN_Callback_JoyIndex (cvar_t *var)
 		{
 			int numaxes, numbtns, numballs, numhats;
 			Con_Printf("joystick open ");
+#if SDLQUAKE == 2
+			Con_Printf("#%d: \"%s\"\n", idx, SDL_JoystickNameForIndex(idx));
+#else
 			Con_Printf("#%d: \"%s\"\n", idx, SDL_JoystickName(idx));
+#endif
 			numaxes = SDL_JoystickNumAxes(joy_id);
 			numbtns = SDL_JoystickNumButtons(joy_id);
 			numballs= SDL_JoystickNumBalls(joy_id);
@@ -819,13 +853,28 @@ void IN_SendKeyEvents (void)
 	if ((gamekey = Key_IsGameKey()) != prev_gamekey)
 	{
 		prev_gamekey = gamekey;
+#if SDLQUAKE < 2
 		SDL_EnableUNICODE(!gamekey);
+#endif
 	}
 
 	while (SDL_PollEvent(&event))
 	{
 		switch (event.type)
 		{
+#if SDLQUAKE == 2
+		case SDL_WINDOWEVENT:
+			switch (event.window.event)
+			{
+			case SDL_WINDOWEVENT_FOCUS_GAINED:
+				S_UnblockSound();
+				break;
+			case SDL_WINDOWEVENT_FOCUS_LOST:
+				S_BlockSound();
+				break;
+			}
+			break;
+#else
 		case SDL_ACTIVEEVENT:
 			if (event.active.state & (SDL_APPINPUTFOCUS|SDL_APPACTIVE))
 			{
@@ -834,6 +883,7 @@ void IN_SendKeyEvents (void)
 				else	S_BlockSound();
 			}
 			break;
+#endif
 
 		case SDL_KEYDOWN:
 			if ((event.key.keysym.sym == SDLK_RETURN) &&
@@ -851,8 +901,12 @@ void IN_SendKeyEvents (void)
 			if ((event.key.keysym.sym == SDLK_g) &&
 			    (event.key.keysym.mod & KMOD_CTRL))
 			{
+#if SDLQUAKE == 2
+				SDL_SetRelativeMouseMode(!SDL_GetRelativeMouseMode());
+#else
 				SDL_WM_GrabInput((SDL_WM_GrabInput (SDL_GRAB_QUERY) == SDL_GRAB_ON) ?
 									  SDL_GRAB_OFF : SDL_GRAB_ON);
+#endif
 				break;
 			}
 		/* fallthrough */
@@ -861,6 +915,7 @@ void IN_SendKeyEvents (void)
 			state = event.key.state;
 			modstate = SDL_GetModState();
 
+#if SDLQUAKE < 2
 			if (event.key.keysym.unicode != 0)
 			{
 				if ((event.key.keysym.unicode & 0xFF80) == 0)
@@ -888,6 +943,7 @@ void IN_SendKeyEvents (void)
 				/* else: it's an international character */
 			}
 			/*printf("You pressed %s (%d) (%c)\n", SDL_GetKeyName(sym), sym, sym);*/
+#endif
 
 			switch (sym)
 			{
@@ -933,7 +989,9 @@ void IN_SendKeyEvents (void)
 			case SDLK_F12:
 				sym = K_F12;
 				break;
+#if SDLQUAKE < 2
 			case SDLK_BREAK:
+#endif
 			case SDLK_PAUSE:
 				sym = K_PAUSE;
 				break;
@@ -976,61 +1034,110 @@ void IN_SendKeyEvents (void)
 			case SDLK_LALT:
 				sym = K_ALT;
 				break;
+#if SDLQUAKE == 2
+			case SDLK_RGUI:
+			case SDLK_LGUI:
+#else
 			case SDLK_RMETA:
 			case SDLK_LMETA:
+#endif
 				sym = K_COMMAND;
 				break;
+#if SDLQUAKE == 2
+			case SDLK_NUMLOCKCLEAR:
+#else
 			case SDLK_NUMLOCK:
+#endif
 				if (gamekey)
 					sym = K_KP_NUMLOCK;
 				else	sym = 0;
 				break;
+#if SDLQUAKE == 2
+			case SDLK_KP_0:
+#else
 			case SDLK_KP0:
+#endif
 				if (gamekey)
 					sym = K_KP_INS;
 				else	sym = (modstate & KMOD_NUM) ? SDLK_0 : K_INS;
 				break;
+#if SDLQUAKE == 2
+			case SDLK_KP_1:
+#else
 			case SDLK_KP1:
+#endif
 				if (gamekey)
 					sym = K_KP_END;
 				else	sym = (modstate & KMOD_NUM) ? SDLK_1 : K_END;
 				break;
+#if SDLQUAKE == 2
+			case SDLK_KP_2:
+#else
 			case SDLK_KP2:
+#endif
 				if (gamekey)
 					sym = K_KP_DOWNARROW;
 				else	sym = (modstate & KMOD_NUM) ? SDLK_2 : K_DOWNARROW;
 				break;
+#if SDLQUAKE == 2
+			case SDLK_KP_3:
+#else
 			case SDLK_KP3:
+#endif
 				if (gamekey)
 					sym = K_KP_PGDN;
 				else	sym = (modstate & KMOD_NUM) ? SDLK_3 : K_PGDN;
 				break;
+#if SDLQUAKE == 2
+			case SDLK_KP_4:
+#else
 			case SDLK_KP4:
+#endif
 				if (gamekey)
 					sym = K_KP_LEFTARROW;
 				else	sym = (modstate & KMOD_NUM) ? SDLK_4 : K_LEFTARROW;
 				break;
+#if SDLQUAKE == 2
+			case SDLK_KP_5:
+#else
 			case SDLK_KP5:
+#endif
 				if (gamekey)
 					sym = K_KP_5;
 				else	sym = SDLK_5;
 				break;
+#if SDLQUAKE == 2
+			case SDLK_KP_6:
+#else
 			case SDLK_KP6:
+#endif
 				if (gamekey)
 					sym = K_KP_RIGHTARROW;
 				else	sym = (modstate & KMOD_NUM) ? SDLK_6 : K_RIGHTARROW;
 				break;
+#if SDLQUAKE == 2
+			case SDLK_KP_7:
+#else
 			case SDLK_KP7:
+#endif
 				if (gamekey)
 					sym = K_KP_HOME;
 				else	sym = (modstate & KMOD_NUM) ? SDLK_7 : K_HOME;
 				break;
+#if SDLQUAKE == 2
+			case SDLK_KP_8:
+#else
 			case SDLK_KP8:
+#endif
 				if (gamekey)
 					sym = K_KP_UPARROW;
 				else	sym = (modstate & KMOD_NUM) ? SDLK_8 : K_UPARROW;
 				break;
+#if SDLQUAKE == 2
+			case SDLK_KP_9:
+#else
 			case SDLK_KP9:
+#endif
 				if (gamekey)
 					sym = K_KP_PGUP;
 				else	sym = (modstate & KMOD_NUM) ? SDLK_9 : K_PGUP;
@@ -1070,15 +1177,19 @@ void IN_SendKeyEvents (void)
 					sym = 0;
 				else	sym = SDLK_EQUALS;
 				break;
-			case 178: /* the '²' key */
+			case 178: /* the 'ï¿½' key */
 				sym = '~';
 				break;
 			default:
+#if SDLQUAKE == 2
+				if (sym > 255)
+#else
 			/* If we are not directly handled and still above 255,
 			 * just force it to 0. kill unsupported international
 			 * characters, too.  */
 				if ((sym >= SDLK_WORLD_0 && sym <= SDLK_WORLD_95) ||
 									sym > 255)
+#endif
 					sym = 0;
 				break;
 			}
@@ -1100,6 +1211,15 @@ void IN_SendKeyEvents (void)
 			Key_Event(buttonremap[event.button.button - 1], event.button.state == SDL_PRESSED);
 			break;
 
+#if SDLQUAKE == 2
+		case SDL_MOUSEWHEEL:
+			if (!mouseactive || in_mode_set)
+				break;
+			Key_Event( (event.wheel.y > 0 ? K_MWHEELUP : K_MWHEELDOWN), true);
+			Key_Event( (event.wheel.y > 0 ? K_MWHEELUP : K_MWHEELDOWN), false);
+			break;
+#endif
+
 		case SDL_JOYBUTTONDOWN:
 		case SDL_JOYBUTTONUP:
 			if (in_mode_set)
diff --git a/engine/h2shared/sdl_inc.h b/engine/h2shared/sdl_inc.h
index a54999a0..aef6a5c4 100644
--- a/engine/h2shared/sdl_inc.h
+++ b/engine/h2shared/sdl_inc.h
@@ -28,11 +28,23 @@
 #endif	/* SDLQUAKE */
 
 #if defined(SDL_FRAMEWORK) || defined(NO_SDL_CONFIG)
+
+#if SDLQUAKE == 2
+#include <SDL2/SDL.h>
+#else
 #include <SDL/SDL.h>
+#endif
+
+#else
+
+#if SDLQUAKE == 2
+#include "SDL2/SDL.h"
 #else
 #include "SDL.h"
 #endif
 
+#endif
+
 /* =================================================================
 Minimum required SDL versions:
 Although the 1.1.x series might work fine, we require at least 1.2.0
@@ -81,7 +93,6 @@ hence the SDL_NEW_VERSION_REJECT macro below.
 #error SDL version found is too old
 #endif
 
-
 /* the defines below are actually part of SDL_GLattr enums in SDL
    versions supporting that relevant feature. */
 
diff --git a/engine/h2shared/snd_sdl.c b/engine/h2shared/snd_sdl.c
index 26742cc3..31207947 100644
--- a/engine/h2shared/snd_sdl.c
+++ b/engine/h2shared/snd_sdl.c
@@ -83,7 +83,11 @@ static qboolean S_SDL_Init (dma_t *dma)
 {
 	SDL_AudioSpec desired, obtained;
 	int		tmp, val;
+#if SDLQUAKE == 2
+	const char *drivername;
+#else
 	char	drivername[128];
+#endif
 
 	if (SDL_InitSubSystem(SDL_INIT_AUDIO) < 0)
 	{
@@ -156,8 +160,14 @@ static qboolean S_SDL_Init (dma_t *dma)
 
 	Con_Printf ("SDL audio spec  : %d Hz, %d samples, %d channels\n",
 			obtained.freq, obtained.samples, obtained.channels);
+#if SDLQUAKE == 2
+	drivername = SDL_GetAudioDeviceName(1, SDL_FALSE);
+	if (!drivername)
+		drivername = "(UNKNOWN)";
+#else
 	if (SDL_AudioDriverName(drivername, sizeof(drivername)) == NULL)
 		strcpy(drivername, "(UNKNOWN)");
+#endif
 	buffersize = shm->samples * (shm->samplebits / 8);
 	Con_Printf ("SDL audio driver: %s, %d bytes buffer\n", drivername, buffersize);
 
diff --git a/engine/h2shared/vid_sdl.c b/engine/h2shared/vid_sdl.c
index 32bd3a58..e715ab93 100644
--- a/engine/h2shared/vid_sdl.c
+++ b/engine/h2shared/vid_sdl.c
@@ -61,6 +61,12 @@ static int	num_fmodes;
 static int	num_wmodes;
 static int	*nummodes;
 //static int	bpp = 8;
+#if SDLQUAKE == 2
+SDL_Window *window;
+static SDL_Renderer *renderer;
+static SDL_Texture *screen_tex;
+static SDL_Surface *tex_surface;
+#endif
 static SDL_Surface	*screen;
 static qboolean	vid_menu_fs;
 static qboolean	fs_toggle_works = true;
@@ -146,12 +152,20 @@ static void VID_MenuKey (int key);
 
 qboolean VID_HasMouseOrInputFocus (void)
 {
+#if SDLQUAKE == 2
+	return (SDL_GetWindowFlags(window) & (SDL_WINDOW_MOUSE_FOCUS | SDL_WINDOW_INPUT_FOCUS)) != 0;
+#else
 	return (SDL_GetAppState() & (SDL_APPMOUSEFOCUS | SDL_APPINPUTFOCUS)) != 0;
+#endif
 }
 
 qboolean VID_IsMinimized (void)
 {
+#if SDLQUAKE == 2
+	return !(SDL_GetWindowFlags(window) & SDL_WINDOW_SHOWN);
+#else
 	return !(SDL_GetAppState() & SDL_APPACTIVE);
+#endif
 }
 
 
@@ -262,16 +276,29 @@ static void VID_SetIcon (void)
 	if (icon == NULL)
 		return;
 
+#if SDLQUAKE == 2
+	SDL_SetColorKey(icon, SDL_TRUE, 0);
+#else
 	SDL_SetColorKey(icon, SDL_SRCCOLORKEY, 0);
+#endif
 
 	color.r = 255;
 	color.g = 255;
 	color.b = 255;
-	SDL_SetColors(icon, &color, 0, 1);	/* just in case */
+	/* just in case */
+#if SDLQUAKE == 2
+	SDL_SetPaletteColors(icon->format->palette, &color, 0, 1);
+#else
+	SDL_SetColors(icon, &color, 0, 1);	
+#endif
 	color.r = 192;
 	color.g = 0;
 	color.b = 0;
+#if SDLQUAKE == 2
+	SDL_SetPaletteColors(icon->format->palette, &color, 1, 1);
+#else
 	SDL_SetColors(icon, &color, 1, 1);
+#endif
 
 	ptr = (Uint8 *)icon->pixels;
 	/* one bit represents a pixel, black or white:  each
@@ -285,8 +312,13 @@ static void VID_SetIcon (void)
 		}
 	}
 
+#if SDLQUAKE == 2
+	SDL_SetWindowIcon(window, icon);
+#else
 	SDL_WM_SetIcon(icon, NULL);
+#endif
 	SDL_FreeSurface(icon);
+
 #endif /* !OSX */
 }
 
@@ -304,11 +336,69 @@ static int sort_modes (const void *arg1, const void *arg2)
 	//	return a2->w - a1->w;	// highres-to-lowres
 }
 
-static void VID_PrepareModes (SDL_Rect **sdl_modes)
+static void VID_PrepareModes (void)
 {
 	int	i, j;
 	qboolean	have_mem, is_multiple;
+	SDL_Rect	**sdl_modes;
 	SDL_Rect	**cpy_modes;
+#if SDLQUAKE == 2
+	int k;
+	SDL_DisplayMode	mode;
+	SDL_Rect	mode_rects[MAX_MODE_LIST];
+	SDL_Rect	*ptr_array[MAX_MODE_LIST + 1];
+#endif
+
+#if SDLQUAKE == 2
+	// SDL2 does not have a function to get the full modelist, so we must build it manually.
+
+	num_fmodes = 0;
+
+	// Fill the list with all modes supported by the first display.
+	for (i = 0; i < SDL_GetNumDisplayModes(0) && i < MAX_MODE_LIST; i++)
+	{
+		SDL_GetDisplayMode(0, i, &mode);
+		mode_rects[num_fmodes].x = 0;
+		mode_rects[num_fmodes].y = 0;
+		mode_rects[num_fmodes].w = mode.w;
+		mode_rects[num_fmodes].h = mode.h;
+		num_fmodes++;
+	}
+
+	// Check the other displays and add any modes that aren't already in the list
+	for (i = 1; i < SDL_GetNumVideoDisplays(); i++)
+		for (j = 0; j < SDL_GetNumDisplayModes(i) && num_fmodes < MAX_MODE_LIST; j++)
+		{
+			SDL_GetDisplayMode(i, j, &mode);
+			mode_rects[num_fmodes].x = 0;
+			mode_rects[num_fmodes].y = 0;
+			mode_rects[num_fmodes].w = mode.w;
+			mode_rects[num_fmodes].h = mode.h;
+			num_fmodes++;
+
+			for (k = 0; k < num_fmodes; k++)
+			{
+				if (mode.w == mode_rects[k].w && mode.h == mode_rects[k].h)
+				{
+					num_fmodes--;
+					break;
+				}
+			}
+		}
+
+	if (num_fmodes > 0)
+	{
+		for (i = 0; i < num_fmodes; i++)
+			ptr_array[i] = &mode_rects[i];
+		ptr_array[num_fmodes] = NULL;
+		sdl_modes = ptr_array;
+	}
+	else
+		sdl_modes = NULL;
+#else
+	// retrieve the list of fullscreen modes
+	sdl_modes = SDL_ListModes(NULL, SDL_OPENGL|SDL_FULLSCREEN);
+#endif
 
 	num_fmodes = 0;
 	num_wmodes = 0;
@@ -507,9 +597,116 @@ static qboolean VID_SetMode (int modenum, const unsigned char *palette)
 {
 	Uint32 flags;
 	int	is_fullscreen;
+#if SDLQUAKE == 2
+	int display_index;
+	SDL_DisplayMode desktop_mode;
+	int screen_w, screen_h;
+	int format;
+	void *pixels;
+	int pitch;
+#endif
 
 	in_mode_set = true;
 
+#if SDLQUAKE == 2
+	if (window)
+	{
+		SDL_FreeSurface(screen);
+		screen = NULL;
+		SDL_FreeSurface(tex_surface);
+		tex_surface = NULL;
+		SDL_DestroyTexture(screen_tex);
+		screen_tex = NULL;
+		SDL_DestroyRenderer(renderer);
+		renderer = NULL;
+		SDL_DestroyWindow(window);
+		window = NULL;
+	}
+
+	flags = 0;
+	window = SDL_CreateWindow("", SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED, modelist[modenum].width, modelist[modenum].height, flags);
+
+	if (!window)
+		return false;
+
+	if (vid_config_fscr.integer)
+	{
+		flags = SDL_WINDOW_FULLSCREEN;
+
+		// Try to check the desktop resolution. If it matches the window size, use a borderless window
+		display_index = SDL_GetWindowDisplayIndex(window);
+		if (display_index >= 0 && SDL_GetDesktopDisplayMode(display_index, &desktop_mode) == 0)
+		{
+			SDL_GetWindowSize(window, &screen_w, &screen_h);
+			if (screen_w == desktop_mode.w && screen_h == desktop_mode.h)
+			{
+				flags = SDL_WINDOW_FULLSCREEN_DESKTOP;
+				Con_Printf ("Fullscreen res matches desktop; using borderless window\n");
+			}
+		}
+		else
+			Con_Printf ("Failed to query desktop display mode; using native fullscreen\n");
+	}
+
+	SDL_SetWindowFullscreen(window, flags);
+
+	VID_SetIcon();
+	SDL_SetWindowTitle(window, WM_TITLEBAR_TEXT);
+
+	renderer = SDL_CreateRenderer(window, -1, 0);
+	if (!renderer)
+	{
+		SDL_DestroyWindow(window);
+		window = NULL;
+		return false;
+	}
+
+	format = SDL_GetWindowPixelFormat(window);
+	if (format == SDL_PIXELFORMAT_UNKNOWN)
+		format = SDL_PIXELFORMAT_RGBA32;
+	screen_tex = SDL_CreateTexture(renderer, format, SDL_TEXTUREACCESS_STREAMING, modelist[modenum].width, modelist[modenum].height);
+	if (!screen_tex)
+	{
+		SDL_DestroyRenderer(renderer);
+		renderer = NULL;
+		SDL_DestroyWindow(window);
+		window = NULL;
+		return false;
+	}
+
+	// Create a "fake" surface that we can redirect to the texture memory when we lock it.
+	SDL_LockTexture(screen_tex, NULL, &pixels, &pitch);
+	tex_surface = SDL_CreateRGBSurfaceWithFormatFrom(pixels, modelist[modenum].width, modelist[modenum].height, SDL_BITSPERPIXEL(format), pitch, format);
+	SDL_UnlockTexture(screen_tex);
+
+	screen = SDL_CreateRGBSurface(0, modelist[modenum].width, modelist[modenum].height, 8, 0, 0, 0, 0);
+
+	if (!tex_surface || !screen)
+	{
+		if (tex_surface)
+		{
+			SDL_FreeSurface(tex_surface);
+			tex_surface = NULL;
+		}
+		if (screen)
+		{
+			SDL_FreeSurface(screen);
+			screen = NULL;	
+		}
+
+		SDL_DestroyTexture(screen_tex);
+		screen_tex = NULL;
+		SDL_DestroyRenderer(renderer);
+		renderer = NULL;
+		SDL_DestroyWindow(window);
+		window = NULL;
+
+		return false;
+	}
+
+	tex_surface->pixels = NULL;
+	is_fullscreen = (SDL_GetWindowFlags(window) & (SDL_WINDOW_FULLSCREEN | SDL_WINDOW_FULLSCREEN_DESKTOP)) ? 1 : 0;
+#else
 	if (screen)
 		SDL_FreeSurface(screen);
 
@@ -524,6 +721,10 @@ static qboolean VID_SetMode (int modenum, const unsigned char *palette)
 	if (!screen)
 		return false;
 
+	is_fullscreen = (screen->flags & SDL_FULLSCREEN) ? 1 : 0;
+	SDL_WM_SetCaption(WM_TITLEBAR_TEXT, WM_ICON_TEXT);
+#endif
+
 	// initial success. adjust vid vars.
 	vid.height = vid.conheight = modelist[modenum].height;
 	vid.width = vid.conwidth = modelist[modenum].width;
@@ -539,7 +740,6 @@ static qboolean VID_SetMode (int modenum, const unsigned char *palette)
 
 	// real success. set vid_modenum properly.
 	vid_modenum = modenum;
-	is_fullscreen = (screen->flags & SDL_FULLSCREEN) ? 1 : 0;
 	modestate = (is_fullscreen) ? MS_FULLDIB : MS_WINDOWED;
 	Cvar_SetValueQuick (&vid_config_swx, modelist[vid_modenum].width);
 	Cvar_SetValueQuick (&vid_config_swy, modelist[vid_modenum].height);
@@ -551,8 +751,6 @@ static qboolean VID_SetMode (int modenum, const unsigned char *palette)
 
 	VID_SetPalette (palette);
 
-	SDL_WM_SetCaption(WM_TITLEBAR_TEXT, WM_ICON_TEXT);
-
 	Con_SafePrintf ("Video Mode: %ux%ux%d\n", vid.width, vid.height, modelist[modenum].bpp);
 
 	in_mode_set = false;
@@ -666,7 +864,11 @@ void VID_SetPalette (const unsigned char *palette)
 		colors[i].b = *palette++;
 	}
 
+#if SDLQUAKE == 2
+	SDL_SetPaletteColors(screen->format->palette, colors, 0, 256);
+#else
 	SDL_SetColors(screen, colors, 0, 256);
+#endif
 }
 
 
@@ -684,7 +886,6 @@ VID_Init
 void VID_Init (const unsigned char *palette)
 {
 	int		width, height, i, temp;
-	SDL_Rect	**enumlist;
 	const char	*read_vars[] = {
 				"vid_config_fscr",
 				"vid_config_swx",
@@ -715,10 +916,8 @@ void VID_Init (const unsigned char *palette)
 			Sys_Error("Couldn't init video: %s", SDL_GetError());
 	}
 
-	// retrieve the list of fullscreen modes
-	enumlist = SDL_ListModes(NULL, SDL_SWSURFACE|SDL_HWPALETTE|SDL_FULLSCREEN);
 	// prepare the modelists, find the actual modenum for vid_default
-	VID_PrepareModes(enumlist);
+	VID_PrepareModes();
 
 	// set vid_mode to our safe default first
 	Cvar_SetValueQuick (&vid_mode, vid_default);
@@ -842,12 +1041,48 @@ FlipScreen
 */
 static void FlipScreen (vrect_t *rects)
 {
+#if SDLQUAKE == 2
+	vrect_t *orig_rects = rects;
+	SDL_Rect sdl_rect;
+	int pitch = 0;
+
+	SDL_LockTexture(screen_tex, NULL, &tex_surface->pixels, &pitch);
+#endif
+
 	while (rects)
 	{
+#if SDLQUAKE == 2
+		sdl_rect.x = rects->x;
+		sdl_rect.y = rects->y;
+		sdl_rect.w = rects->width;
+		sdl_rect.h = rects->height;
+
+		SDL_BlitSurface(screen, &sdl_rect, tex_surface, &sdl_rect);
+#else
 		SDL_UpdateRect (screen, rects->x, rects->y, rects->width,
 				rects->height);
+#endif
 		rects = rects->pnext;
 	}
+
+#if SDLQUAKE == 2
+	SDL_UnlockTexture(screen_tex);
+	tex_surface->pixels = NULL;
+
+	rects = orig_rects;
+	while (rects)
+	{
+		sdl_rect.x = rects->x;
+		sdl_rect.y = rects->y;
+		sdl_rect.w = rects->width;
+		sdl_rect.h = rects->height;
+
+		SDL_RenderCopy(renderer, screen_tex, &sdl_rect, &sdl_rect);
+		rects = rects->pnext;
+	}
+
+	SDL_RenderPresent(renderer);
+#endif
 }
 
 void VID_Update (vrect_t *rects)
@@ -910,12 +1145,32 @@ D_EndDirectRect
 */
 void D_EndDirectRect (int x, int y, int width, int height)
 {
+#if SDLQUAKE == 2
+	SDL_Rect sdl_rect;
+	int pitch;
+#endif
+
 //	these bits from quakeforge
 	if (!screen)
 		return;
 	if (x < 0)
 		x = screen->w + x - 1;
+
+#if SDLQUAKE == 2
+	sdl_rect.x = x;
+	sdl_rect.y = y;
+	sdl_rect.w = width;
+	sdl_rect.h = height;
+
+	SDL_LockTexture(screen_tex, NULL, &tex_surface->pixels, &pitch);
+	SDL_BlitSurface(screen, &sdl_rect, tex_surface, &sdl_rect);
+	SDL_UnlockTexture(screen_tex);
+	tex_surface->pixels = NULL;
+	SDL_RenderCopy(renderer, screen_tex, &sdl_rect, &sdl_rect);
+	SDL_RenderPresent(renderer);
+#else
 	SDL_UpdateRect (screen, x, y, width, height);
+#endif
 }
 
 
@@ -1031,19 +1286,61 @@ extern qboolean menu_disabled_mouse;
 void VID_ToggleFullscreen (void)
 {
 	int	is_fullscreen;
+#if SDLQUAKE == 2
+	int display_index;
+	SDL_DisplayMode desktop_mode;
+	int screen_w, screen_h;
+	int fullscreen_flag;
+#endif
 
 	if (!fs_toggle_works)
 		return;
 	if (!num_fmodes)
 		return;
+#if SDLQUAKE == 2
+	if (!window)
+#else
 	if (!screen)
+#endif
 		return;
 
 	S_ClearBuffer ();
 
+#if SDLQUAKE == 2
+	is_fullscreen = SDL_GetWindowFlags(window) & (SDL_WINDOW_FULLSCREEN | SDL_WINDOW_FULLSCREEN_DESKTOP);
+
+	// If we're switching to fullscreen, check to see if our window has the same size as the desktop.
+	// If it does, use a borderless window instead of "real" fullscreen for better wm integration.
+	if (!is_fullscreen)
+	{
+		fullscreen_flag = SDL_WINDOW_FULLSCREEN;
+
+		display_index = SDL_GetWindowDisplayIndex(window);
+		if (display_index >= 0 && SDL_GetDesktopDisplayMode(display_index, &desktop_mode) == 0)
+		{
+			SDL_GetWindowSize(window, &screen_w, &screen_h);
+			if (screen_w == desktop_mode.w && screen_h == desktop_mode.h)
+			{
+				fullscreen_flag = SDL_WINDOW_FULLSCREEN_DESKTOP;
+				Con_Printf ("Fullscreen res matches desktop; using borderless window\n");
+			}
+		}
+		else
+			Con_Printf ("Failed to query desktop display mode; using native fullscreen\n");
+	}
+	else
+		fullscreen_flag = 0;
+
+	if (SDL_SetWindowFullscreen(window, fullscreen_flag) == 0)
+#else
 	if (SDL_WM_ToggleFullScreen(screen) == 1)
+#endif
 	{
+#if SDLQUAKE == 2
+		is_fullscreen = !is_fullscreen;
+#else
 		is_fullscreen = (screen->flags & SDL_FULLSCREEN) ? 1 : 0;
+#endif
 		Cvar_SetValueQuick(&vid_config_fscr, is_fullscreen);
 		modestate = (is_fullscreen) ? MS_FULLDIB : MS_WINDOWED;
 		if (is_fullscreen)
@@ -1065,7 +1362,11 @@ void VID_ToggleFullscreen (void)
 	else
 	{
 		fs_toggle_works = false;
+#if SDLQUAKE == 2
+		Con_Printf ("SDL_SetWindowFulscreen failed\n");
+#else
 		Con_Printf ("SDL_WM_ToggleFullScreen failed\n");
+#endif
 	}
 }
 
diff --git a/engine/hexen2/Makefile b/engine/hexen2/Makefile
index 28e84dd6..c0535503 100644
--- a/engine/hexen2/Makefile
+++ b/engine/hexen2/Makefile
@@ -48,8 +48,18 @@ OSLIBS:=$(UHEXEN2_TOP)/oslibs
 
 # X directory
 X11BASE    =/usr/X11R6
+
+# which major SDL version to use
+# ignored for legacy platforms without SDL2 support
+SDL_API    = 2
+
 # the sdl-config command
+ifeq ($(SDL_API),2)
+SDL_CONFIG =sdl2-config
+else
 SDL_CONFIG =sdl-config
+endif
+
 SDL_CFLAGS = $(shell $(SDL_CONFIG) --cflags 2> /dev/null)
 SDL_LIBS   = $(shell $(SDL_CONFIG) --libs 2> /dev/null)
 
@@ -348,7 +358,7 @@ endif
 
 # Unix builds rely on SDL:
 # SDLQUAKE must be defined for all SDL using platforms/targets
-CPPFLAGS+= -DSDLQUAKE
+CPPFLAGS+= -DSDLQUAKE=$(SDL_API)
 # not relying on sdl-config command and assuming
 # /Library/Frameworks/SDL.framework is available
 SDL_CFLAGS =-D_GNU_SOURCE=1 -D_THREAD_SAFE
@@ -456,7 +466,7 @@ endif
 
 # Unix builds rely on SDL:
 # SDLQUAKE must be defined for all SDL using platforms/targets
-CPPFLAGS+= -DSDLQUAKE
+CPPFLAGS+= -DSDLQUAKE=$(SDL_API)
 CFLAGS  += $(SDL_CFLAGS)
 LDFLAGS += $(SDL_LIBS)
 
@@ -489,6 +499,7 @@ LDFLAGS += -s
 CFLAGS  += -fno-omit-frame-pointer
 endif
 # using SDL for now:
+SDL_API=1
 SDL_CFLAGS=-I$(OSLIBS)/os2/SDL/include
 SDL_LIBS = -L$(OSLIBS)/os2/SDL/lib -lSDL12
 USE_SDLCD=yes
@@ -514,7 +525,7 @@ endif
 endif
 
 # SDLQUAKE must be defined for all SDL using platforms/targets
-CPPFLAGS+= -DSDLQUAKE
+CPPFLAGS+= -DSDLQUAKE=$(SDL_API)
 CFLAGS  += $(SDL_CFLAGS)
 LDFLAGS += $(SDL_LIBS)
 
@@ -839,6 +850,7 @@ ifeq ($(TARGET_OS),morphos)
 
 # MorphOS builds can use SDL or native code
 USE_SDL=no
+SDL_API=1
 ifneq ($(USE_SDL),yes)
 USE_SDLCD=no
 USE_SDLAUDIO=no
@@ -898,7 +910,7 @@ endif
 
 ifeq ($(USE_SDL),yes)
 # SDLQUAKE must be defined for all SDL using platforms/targets
-CPPFLAGS+= -DSDLQUAKE
+CPPFLAGS+= -DSDLQUAKE=$(SDL_API)
 CFLAGS  += $(SDL_CFLAGS)
 LDFLAGS += $(SDL_LIBS)
 endif
@@ -915,6 +927,7 @@ ifeq ($(TARGET_OS),aros)
 
 # AROS builds can use SDL or native code
 USE_SDL=no
+SDL_API=1
 ifneq ($(USE_SDL),yes)
 USE_SDLCD=no
 USE_SDLAUDIO=no
@@ -980,7 +993,7 @@ endif
 
 ifeq ($(USE_SDL),yes)
 # SDLQUAKE must be defined for all SDL using platforms/targets
-CPPFLAGS+= -DSDLQUAKE
+CPPFLAGS+= -DSDLQUAKE=$(SDL_API)
 CFLAGS  += $(SDL_CFLAGS)
 LDFLAGS += $(SDL_LIBS)
 endif
@@ -1000,6 +1013,7 @@ USE_CLIB2=yes
 
 # Don't use SDL on AmigaOS
 USE_SDL=no
+SDL_API=1
 ifneq ($(USE_SDL),yes)
 USE_SDLCD=no
 USE_SDLAUDIO=no
@@ -1082,7 +1096,7 @@ endif
 
 ifeq ($(USE_SDL),yes)
 # SDLQUAKE must be defined for all SDL using platforms/targets
-CPPFLAGS+= -DSDLQUAKE
+CPPFLAGS+= -DSDLQUAKE=$(SDL_API)
 CFLAGS  += $(SDL_CFLAGS)
 LDFLAGS += $(SDL_LIBS)
 endif
diff --git a/engine/hexen2/sys_unix.c b/engine/hexen2/sys_unix.c
index cd0dc3c1..ee76f853 100644
--- a/engine/hexen2/sys_unix.c
+++ b/engine/hexen2/sys_unix.c
@@ -50,6 +50,9 @@
 #include "sdl_inc.h"
 #endif	/* SDLQUAKE */
 
+#if SDLQUAKE == 2
+extern SDL_Window *window;
+#endif
 
 // heapsize: minimum 16mb, standart 32 mb, max is 96 mb.
 // -heapsize argument will abide by these min/max settings
@@ -575,9 +578,17 @@ static int Sys_GetUserdir (char *dst, size_t dstsize)
 static void Sys_CheckSDL (void)
 {
 #if defined(SDLQUAKE)
+#if SDLQUAKE == 2
+	SDL_version local_sdl_version;
+#endif
 	const SDL_version *sdl_version;
 
+#if SDLQUAKE == 2
+	SDL_GetVersion(&local_sdl_version);
+	sdl_version = &local_sdl_version;
+#else
 	sdl_version = SDL_Linked_Version();
+#endif
 	Sys_Printf("Found SDL version %i.%i.%i\n",sdl_version->major,sdl_version->minor,sdl_version->patch);
 	if (SDL_VERSIONNUM(sdl_version->major,sdl_version->minor,sdl_version->patch) < SDL_REQUIREDVERSION)
 	{	/*reject running under SDL versions older than what is stated in sdl_inc.h */
diff --git a/engine/hexenworld/client/Makefile b/engine/hexenworld/client/Makefile
index f0043240..22c82988 100644
--- a/engine/hexenworld/client/Makefile
+++ b/engine/hexenworld/client/Makefile
@@ -50,8 +50,18 @@ OSLIBS:=$(UHEXEN2_TOP)/oslibs
 
 # X directory
 X11BASE    =/usr/X11R6
+
+# which major SDL version to use
+# ignored for legacy platforms without SDL2 support
+SDL_API    = 2
+
 # the sdl-config command
+ifeq ($(SDL_API),2)
+SDL_CONFIG =sdl2-config
+else
 SDL_CONFIG =sdl-config
+endif
+
 SDL_CFLAGS = $(shell $(SDL_CONFIG) --cflags 2> /dev/null)
 SDL_LIBS   = $(shell $(SDL_CONFIG) --libs 2> /dev/null)
 
@@ -309,7 +319,7 @@ endif
 
 # Unix builds rely on SDL:
 # SDLQUAKE must be defined for all SDL using platforms/targets
-CPPFLAGS+= -DSDLQUAKE
+CPPFLAGS+= -DSDLQUAKE=$(SDL_API)
 # not relying on sdl-config command and assuming
 # /Library/Frameworks/SDL.framework is available
 SDL_CFLAGS =-D_GNU_SOURCE=1 -D_THREAD_SAFE
@@ -417,7 +427,7 @@ endif
 
 # Unix builds rely on SDL:
 # SDLQUAKE must be defined for all SDL using platforms/targets
-CPPFLAGS+= -DSDLQUAKE
+CPPFLAGS+= -DSDLQUAKE=$(SDL_API)
 CFLAGS  += $(SDL_CFLAGS)
 LDFLAGS += $(SDL_LIBS)
 
@@ -450,6 +460,7 @@ LDFLAGS += -s
 CFLAGS  += -fno-omit-frame-pointer
 endif
 # using SDL for now:
+SDL_API=1
 SDL_CFLAGS=-I$(OSLIBS)/os2/SDL/include
 SDL_LIBS = -L$(OSLIBS)/os2/SDL/lib -lSDL12
 USE_SDLCD=yes
@@ -475,7 +486,7 @@ endif
 endif
 
 # SDLQUAKE must be defined for all SDL using platforms/targets
-CPPFLAGS+= -DSDLQUAKE
+CPPFLAGS+= -DSDLQUAKE=$(SDL_API)
 CFLAGS  += $(SDL_CFLAGS)
 LDFLAGS += $(SDL_LIBS)
 
@@ -790,6 +801,7 @@ ifeq ($(TARGET_OS),morphos)
 
 # MorphOS builds can use SDL or native code
 USE_SDL=no
+SDL_API=1
 ifneq ($(USE_SDL),yes)
 USE_SDLCD=no
 USE_SDLAUDIO=no
@@ -849,7 +861,7 @@ endif
 
 ifeq ($(USE_SDL),yes)
 # SDLQUAKE must be defined for all SDL using platforms/targets
-CPPFLAGS+= -DSDLQUAKE
+CPPFLAGS+= -DSDLQUAKE=$(SDL_API)
 CFLAGS  += $(SDL_CFLAGS)
 LDFLAGS += $(SDL_LIBS)
 endif
@@ -866,6 +878,7 @@ ifeq ($(TARGET_OS),aros)
 
 # AROS builds can use SDL or native code
 USE_SDL=no
+SDL_API=1
 ifneq ($(USE_SDL),yes)
 USE_SDLCD=no
 USE_SDLAUDIO=no
@@ -931,7 +944,7 @@ endif
 
 ifeq ($(USE_SDL),yes)
 # SDLQUAKE must be defined for all SDL using platforms/targets
-CPPFLAGS+= -DSDLQUAKE
+CPPFLAGS+= -DSDLQUAKE=$(SDL_API)
 CFLAGS  += $(SDL_CFLAGS)
 LDFLAGS += $(SDL_LIBS)
 endif
@@ -951,6 +964,7 @@ USE_CLIB2=yes
 
 # Don't use SDL on AmigaOS
 USE_SDL=no
+SDL_API=1
 ifneq ($(USE_SDL),yes)
 USE_SDLCD=no
 USE_SDLAUDIO=no
@@ -1033,7 +1047,7 @@ endif
 
 ifeq ($(USE_SDL),yes)
 # SDLQUAKE must be defined for all SDL using platforms/targets
-CPPFLAGS+= -DSDLQUAKE
+CPPFLAGS+= -DSDLQUAKE=$(SDL_API)
 CFLAGS  += $(SDL_CFLAGS)
 LDFLAGS += $(SDL_LIBS)
 endif
diff --git a/engine/hexenworld/client/sys_unix.c b/engine/hexenworld/client/sys_unix.c
index 28dc3b98..ea12970b 100644
--- a/engine/hexenworld/client/sys_unix.c
+++ b/engine/hexenworld/client/sys_unix.c
@@ -50,6 +50,9 @@
 #include "sdl_inc.h"
 #endif	/* SDLQUAKE */
 
+#if SDLQUAKE == 2
+extern SDL_Window *window;
+#endif
 
 // heapsize: minimum 16mb, standart 32 mb, max is 96 mb.
 // -heapsize argument will abide by these min/max settings
@@ -520,9 +523,17 @@ static int Sys_GetUserdir (char *dst, size_t dstsize)
 static void Sys_CheckSDL (void)
 {
 #if defined(SDLQUAKE)
+#if SDLQUAKE == 2
+	SDL_version local_sdl_version;
+#endif
 	const SDL_version *sdl_version;
 
+#if SDLQUAKE == 2
+	SDL_GetVersion(&local_sdl_version);
+	sdl_version = &local_sdl_version;
+#else
 	sdl_version = SDL_Linked_Version();
+#endif
 	Sys_Printf("Found SDL version %i.%i.%i\n",sdl_version->major,sdl_version->minor,sdl_version->patch);
 	if (SDL_VERSIONNUM(sdl_version->major,sdl_version->minor,sdl_version->patch) < SDL_REQUIREDVERSION)
 	{	/*reject running under SDL versions older than what is stated in sdl_inc.h */
